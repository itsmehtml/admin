{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * Interval scale\r\n * @module echarts/scale/Interval\r\n */\n\n\nvar roundNumber = numberUtil.round;\n/**\r\n * @alias module:echarts/coord/scale/Interval\r\n * @constructor\r\n */\n\nvar IntervalScale = Scale.extend({\n  type: 'interval',\n  _interval: 0,\n  _intervalPrecision: 2,\n  setExtent: function setExtent(start, end) {\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  },\n  unionExtent: function unionExtent(other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n  },\n\n  /**\r\n   * Get interval\r\n   */\n  getInterval: function getInterval() {\n    return this._interval;\n  },\n\n  /**\r\n   * Set interval\r\n   */\n  setInterval: function setInterval(interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  },\n\n  /**\r\n   * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.\r\n   * @return {Array.<number>}\r\n   */\n  getTicks: function getTicks(expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push(roundNumber(niceTickExtent[0] - interval));\n      } else {\n        ticks.push(extent[0]);\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push(tick); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1]) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push(lastNiceTick + interval);\n      } else {\n        ticks.push(extent[1]);\n      }\n    }\n\n    return ticks;\n  },\n\n  /**\r\n   * @param {number} [splitNumber=5]\r\n   * @return {Array.<Array.<number>>}\r\n   */\n  getMinorTicks: function getMinorTicks(splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick - prevTick;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  },\n\n  /**\r\n   * @param {number} data\r\n   * @param {Object} [opt]\r\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\r\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\r\n   * @return {string}\r\n   */\n  getLabel: function getLabel(data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    data = roundNumber(data, precision, true);\n    return formatUtil.addCommas(data);\n  },\n\n  /**\r\n   * Update interval and extent of intervals for nice ticks\r\n   *\r\n   * @param {number} [splitNumber = 5] Desired number of ticks\r\n   * @param {number} [minInterval]\r\n   * @param {number} [maxInterval]\r\n   */\n  niceTicks: function niceTicks(splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  },\n\n  /**\r\n   * Nice extent.\r\n   * @param {Object} opt\r\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\r\n   * @param {boolean} [opt.fixMin=false]\r\n   * @param {boolean} [opt.fixMax=false]\r\n   * @param {boolean} [opt.minInterval]\r\n   * @param {boolean} [opt.maxInterval]\r\n   */\n  niceExtent: function niceExtent(opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  }\n});\n/**\r\n * @return {module:echarts/scale/Time}\r\n */\n\nIntervalScale.create = function () {\n  return new IntervalScale();\n};\n\nvar _default = IntervalScale;\nmodule.exports = _default;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/echarts/lib/scale/Interval.js"],"names":["numberUtil","require","formatUtil","Scale","helper","roundNumber","round","IntervalScale","extend","type","_interval","_intervalPrecision","setExtent","start","end","thisExtent","_extent","isNaN","parseFloat","unionExtent","other","extent","prototype","call","getInterval","setInterval","interval","_niceExtent","slice","getIntervalPrecision","getTicks","expandToNicedExtent","niceTickExtent","intervalPrecision","ticks","safeLimit","push","tick","length","lastNiceTick","getMinorTicks","splitNumber","minorTicks","getExtent","i","nextTick","prevTick","count","minorTicksGroup","minorInterval","minorTick","getLabel","data","opt","precision","getPrecisionSafe","addCommas","niceTicks","minInterval","maxInterval","span","isFinite","reverse","result","intervalScaleNiceTicks","niceExtent","expandSize","fixMax","fixMin","Math","floor","ceil","create","_default","module","exports"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,UAAU,GAAGC,OAAO,CAAC,gBAAD,CAAxB;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AAEA,IAAIE,KAAK,GAAGF,OAAO,CAAC,SAAD,CAAnB;;AAEA,IAAIG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACA,IAAII,WAAW,GAAGL,UAAU,CAACM,KAA7B;AACA;AACA;AACA;AACA;;AAEA,IAAIC,aAAa,GAAGJ,KAAK,CAACK,MAAN,CAAa;AAC/BC,EAAAA,IAAI,EAAE,UADyB;AAE/BC,EAAAA,SAAS,EAAE,CAFoB;AAG/BC,EAAAA,kBAAkB,EAAE,CAHW;AAI/BC,EAAAA,SAAS,EAAE,mBAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AAC/B,QAAIC,UAAU,GAAG,KAAKC,OAAtB,CAD+B,CACA;;AAE/B,QAAI,CAACC,KAAK,CAACJ,KAAD,CAAV,EAAmB;AACjBE,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBG,UAAU,CAACL,KAAD,CAA1B;AACD;;AAED,QAAI,CAACI,KAAK,CAACH,GAAD,CAAV,EAAiB;AACfC,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBG,UAAU,CAACJ,GAAD,CAA1B;AACD;AACF,GAd8B;AAe/BK,EAAAA,WAAW,EAAE,qBAAUC,KAAV,EAAiB;AAC5B,QAAIC,MAAM,GAAG,KAAKL,OAAlB;AACAI,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB,KAAyBA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAAC,CAAD,CAA1C;AACAA,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB,KAAyBA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAAC,CAAD,CAA1C,EAH4B,CAGoB;;AAEhDb,IAAAA,aAAa,CAACe,SAAd,CAAwBV,SAAxB,CAAkCW,IAAlC,CAAuC,IAAvC,EAA6CF,MAAM,CAAC,CAAD,CAAnD,EAAwDA,MAAM,CAAC,CAAD,CAA9D;AACD,GArB8B;;AAuB/B;AACF;AACA;AACEG,EAAAA,WAAW,EAAE,uBAAY;AACvB,WAAO,KAAKd,SAAZ;AACD,GA5B8B;;AA8B/B;AACF;AACA;AACEe,EAAAA,WAAW,EAAE,qBAAUC,QAAV,EAAoB;AAC/B,SAAKhB,SAAL,GAAiBgB,QAAjB,CAD+B,CACJ;AAC3B;;AAEA,SAAKC,WAAL,GAAmB,KAAKX,OAAL,CAAaY,KAAb,EAAnB;AACA,SAAKjB,kBAAL,GAA0BP,MAAM,CAACyB,oBAAP,CAA4BH,QAA5B,CAA1B;AACD,GAvC8B;;AAyC/B;AACF;AACA;AACA;AACEI,EAAAA,QAAQ,EAAE,kBAAUC,mBAAV,EAA+B;AACvC,QAAIL,QAAQ,GAAG,KAAKhB,SAApB;AACA,QAAIW,MAAM,GAAG,KAAKL,OAAlB;AACA,QAAIgB,cAAc,GAAG,KAAKL,WAA1B;AACA,QAAIM,iBAAiB,GAAG,KAAKtB,kBAA7B;AACA,QAAIuB,KAAK,GAAG,EAAZ,CALuC,CAKvB;;AAEhB,QAAI,CAACR,QAAL,EAAe;AACb,aAAOQ,KAAP;AACD,KATsC,CASrC;;;AAGF,QAAIC,SAAS,GAAG,KAAhB;;AAEA,QAAId,MAAM,CAAC,CAAD,CAAN,GAAYW,cAAc,CAAC,CAAD,CAA9B,EAAmC;AACjC,UAAID,mBAAJ,EAAyB;AACvBG,QAAAA,KAAK,CAACE,IAAN,CAAW/B,WAAW,CAAC2B,cAAc,CAAC,CAAD,CAAd,GAAoBN,QAArB,CAAtB;AACD,OAFD,MAEO;AACLQ,QAAAA,KAAK,CAACE,IAAN,CAAWf,MAAM,CAAC,CAAD,CAAjB;AACD;AACF;;AAED,QAAIgB,IAAI,GAAGL,cAAc,CAAC,CAAD,CAAzB;;AAEA,WAAOK,IAAI,IAAIL,cAAc,CAAC,CAAD,CAA7B,EAAkC;AAChCE,MAAAA,KAAK,CAACE,IAAN,CAAWC,IAAX,EADgC,CACd;;AAElBA,MAAAA,IAAI,GAAGhC,WAAW,CAACgC,IAAI,GAAGX,QAAR,EAAkBO,iBAAlB,CAAlB;;AAEA,UAAII,IAAI,KAAKH,KAAK,CAACA,KAAK,CAACI,MAAN,GAAe,CAAhB,CAAlB,EAAsC;AACpC;AACA;AACA;AACD;;AAED,UAAIJ,KAAK,CAACI,MAAN,GAAeH,SAAnB,EAA8B;AAC5B,eAAO,EAAP;AACD;AACF,KAtCsC,CAsCrC;AACF;;;AAGA,QAAII,YAAY,GAAGL,KAAK,CAACI,MAAN,GAAeJ,KAAK,CAACA,KAAK,CAACI,MAAN,GAAe,CAAhB,CAApB,GAAyCN,cAAc,CAAC,CAAD,CAA1E;;AAEA,QAAIX,MAAM,CAAC,CAAD,CAAN,GAAYkB,YAAhB,EAA8B;AAC5B,UAAIR,mBAAJ,EAAyB;AACvBG,QAAAA,KAAK,CAACE,IAAN,CAAWG,YAAY,GAAGb,QAA1B;AACD,OAFD,MAEO;AACLQ,QAAAA,KAAK,CAACE,IAAN,CAAWf,MAAM,CAAC,CAAD,CAAjB;AACD;AACF;;AAED,WAAOa,KAAP;AACD,GAlG8B;;AAoG/B;AACF;AACA;AACA;AACEM,EAAAA,aAAa,EAAE,uBAAUC,WAAV,EAAuB;AACpC,QAAIP,KAAK,GAAG,KAAKJ,QAAL,CAAc,IAAd,CAAZ;AACA,QAAIY,UAAU,GAAG,EAAjB;AACA,QAAIrB,MAAM,GAAG,KAAKsB,SAAL,EAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,KAAK,CAACI,MAA1B,EAAkCM,CAAC,EAAnC,EAAuC;AACrC,UAAIC,QAAQ,GAAGX,KAAK,CAACU,CAAD,CAApB;AACA,UAAIE,QAAQ,GAAGZ,KAAK,CAACU,CAAC,GAAG,CAAL,CAApB;AACA,UAAIG,KAAK,GAAG,CAAZ;AACA,UAAIC,eAAe,GAAG,EAAtB;AACA,UAAItB,QAAQ,GAAGmB,QAAQ,GAAGC,QAA1B;AACA,UAAIG,aAAa,GAAGvB,QAAQ,GAAGe,WAA/B;;AAEA,aAAOM,KAAK,GAAGN,WAAW,GAAG,CAA7B,EAAgC;AAC9B,YAAIS,SAAS,GAAGlD,UAAU,CAACM,KAAX,CAAiBwC,QAAQ,GAAG,CAACC,KAAK,GAAG,CAAT,IAAcE,aAA1C,CAAhB,CAD8B,CAC4C;;AAE1E,YAAIC,SAAS,GAAG7B,MAAM,CAAC,CAAD,CAAlB,IAAyB6B,SAAS,GAAG7B,MAAM,CAAC,CAAD,CAA/C,EAAoD;AAClD2B,UAAAA,eAAe,CAACZ,IAAhB,CAAqBc,SAArB;AACD;;AAEDH,QAAAA,KAAK;AACN;;AAEDL,MAAAA,UAAU,CAACN,IAAX,CAAgBY,eAAhB;AACD;;AAED,WAAON,UAAP;AACD,GAnI8B;;AAqI/B;AACF;AACA;AACA;AACA;AACA;AACA;AACES,EAAAA,QAAQ,EAAE,kBAAUC,IAAV,EAAgBC,GAAhB,EAAqB;AAC7B,QAAID,IAAI,IAAI,IAAZ,EAAkB;AAChB,aAAO,EAAP;AACD;;AAED,QAAIE,SAAS,GAAGD,GAAG,IAAIA,GAAG,CAACC,SAA3B;;AAEA,QAAIA,SAAS,IAAI,IAAjB,EAAuB;AACrBA,MAAAA,SAAS,GAAGtD,UAAU,CAACuD,gBAAX,CAA4BH,IAA5B,KAAqC,CAAjD;AACD,KAFD,MAEO,IAAIE,SAAS,KAAK,MAAlB,EAA0B;AAC/B;AACAA,MAAAA,SAAS,GAAG,KAAK3C,kBAAjB;AACD,KAZ4B,CAY3B;AACF;;;AAGAyC,IAAAA,IAAI,GAAG/C,WAAW,CAAC+C,IAAD,EAAOE,SAAP,EAAkB,IAAlB,CAAlB;AACA,WAAOpD,UAAU,CAACsD,SAAX,CAAqBJ,IAArB,CAAP;AACD,GA9J8B;;AAgK/B;AACF;AACA;AACA;AACA;AACA;AACA;AACEK,EAAAA,SAAS,EAAE,mBAAUhB,WAAV,EAAuBiB,WAAvB,EAAoCC,WAApC,EAAiD;AAC1DlB,IAAAA,WAAW,GAAGA,WAAW,IAAI,CAA7B;AACA,QAAIpB,MAAM,GAAG,KAAKL,OAAlB;AACA,QAAI4C,IAAI,GAAGvC,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA7B;;AAEA,QAAI,CAACwC,QAAQ,CAACD,IAAD,CAAb,EAAqB;AACnB;AACD,KAPyD,CAOxD;AACF;;;AAGA,QAAIA,IAAI,GAAG,CAAX,EAAc;AACZA,MAAAA,IAAI,GAAG,CAACA,IAAR;AACAvC,MAAAA,MAAM,CAACyC,OAAP;AACD;;AAED,QAAIC,MAAM,GAAG3D,MAAM,CAAC4D,sBAAP,CAA8B3C,MAA9B,EAAsCoB,WAAtC,EAAmDiB,WAAnD,EAAgEC,WAAhE,CAAb;AACA,SAAKhD,kBAAL,GAA0BoD,MAAM,CAAC9B,iBAAjC;AACA,SAAKvB,SAAL,GAAiBqD,MAAM,CAACrC,QAAxB;AACA,SAAKC,WAAL,GAAmBoC,MAAM,CAAC/B,cAA1B;AACD,GA3L8B;;AA6L/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEiC,EAAAA,UAAU,EAAE,oBAAUZ,GAAV,EAAe;AACzB,QAAIhC,MAAM,GAAG,KAAKL,OAAlB,CADyB,CACE;;AAE3B,QAAIK,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAAxB,EAA6B;AAC3B,UAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,CAAlB,EAAqB;AACnB;AACA,YAAI6C,UAAU,GAAG7C,MAAM,CAAC,CAAD,CAAvB,CAFmB,CAES;AAC5B;AACA;AACA;AACA;;AAEA,YAAI,CAACgC,GAAG,CAACc,MAAT,EAAiB;AACf9C,UAAAA,MAAM,CAAC,CAAD,CAAN,IAAa6C,UAAU,GAAG,CAA1B;AACA7C,UAAAA,MAAM,CAAC,CAAD,CAAN,IAAa6C,UAAU,GAAG,CAA1B;AACD,SAHD,MAGO;AACL7C,UAAAA,MAAM,CAAC,CAAD,CAAN,IAAa6C,UAAU,GAAG,CAA1B;AACD;AACF,OAdD,MAcO;AACL7C,QAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACD;AACF;;AAED,QAAIuC,IAAI,GAAGvC,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA7B,CAvByB,CAuBS;;AAElC,QAAI,CAACwC,QAAQ,CAACD,IAAD,CAAb,EAAqB;AACnBvC,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACD;;AAED,SAAKoC,SAAL,CAAeJ,GAAG,CAACZ,WAAnB,EAAgCY,GAAG,CAACK,WAApC,EAAiDL,GAAG,CAACM,WAArD,EA9ByB,CA8B0C;;AAEnE,QAAIjC,QAAQ,GAAG,KAAKhB,SAApB;;AAEA,QAAI,CAAC2C,GAAG,CAACe,MAAT,EAAiB;AACf/C,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAYhB,WAAW,CAACgE,IAAI,CAACC,KAAL,CAAWjD,MAAM,CAAC,CAAD,CAAN,GAAYK,QAAvB,IAAmCA,QAApC,CAAvB;AACD;;AAED,QAAI,CAAC2B,GAAG,CAACc,MAAT,EAAiB;AACf9C,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAYhB,WAAW,CAACgE,IAAI,CAACE,IAAL,CAAUlD,MAAM,CAAC,CAAD,CAAN,GAAYK,QAAtB,IAAkCA,QAAnC,CAAvB;AACD;AACF;AA/O8B,CAAb,CAApB;AAiPA;AACA;AACA;;AAEAnB,aAAa,CAACiE,MAAd,GAAuB,YAAY;AACjC,SAAO,IAAIjE,aAAJ,EAAP;AACD,CAFD;;AAIA,IAAIkE,QAAQ,GAAGlE,aAAf;AACAmE,MAAM,CAACC,OAAP,GAAiBF,QAAjB","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nvar numberUtil = require(\"../util/number\");\r\n\r\nvar formatUtil = require(\"../util/format\");\r\n\r\nvar Scale = require(\"./Scale\");\r\n\r\nvar helper = require(\"./helper\");\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n/**\r\n * Interval scale\r\n * @module echarts/scale/Interval\r\n */\r\nvar roundNumber = numberUtil.round;\r\n/**\r\n * @alias module:echarts/coord/scale/Interval\r\n * @constructor\r\n */\r\n\r\nvar IntervalScale = Scale.extend({\r\n  type: 'interval',\r\n  _interval: 0,\r\n  _intervalPrecision: 2,\r\n  setExtent: function (start, end) {\r\n    var thisExtent = this._extent; //start,end may be a Number like '25',so...\r\n\r\n    if (!isNaN(start)) {\r\n      thisExtent[0] = parseFloat(start);\r\n    }\r\n\r\n    if (!isNaN(end)) {\r\n      thisExtent[1] = parseFloat(end);\r\n    }\r\n  },\r\n  unionExtent: function (other) {\r\n    var extent = this._extent;\r\n    other[0] < extent[0] && (extent[0] = other[0]);\r\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\r\n\r\n    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\r\n  },\r\n\r\n  /**\r\n   * Get interval\r\n   */\r\n  getInterval: function () {\r\n    return this._interval;\r\n  },\r\n\r\n  /**\r\n   * Set interval\r\n   */\r\n  setInterval: function (interval) {\r\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\r\n    // We assume user wan't to set both interval, min, max to get a better result\r\n\r\n    this._niceExtent = this._extent.slice();\r\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\r\n  },\r\n\r\n  /**\r\n   * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.\r\n   * @return {Array.<number>}\r\n   */\r\n  getTicks: function (expandToNicedExtent) {\r\n    var interval = this._interval;\r\n    var extent = this._extent;\r\n    var niceTickExtent = this._niceExtent;\r\n    var intervalPrecision = this._intervalPrecision;\r\n    var ticks = []; // If interval is 0, return [];\r\n\r\n    if (!interval) {\r\n      return ticks;\r\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\r\n\r\n\r\n    var safeLimit = 10000;\r\n\r\n    if (extent[0] < niceTickExtent[0]) {\r\n      if (expandToNicedExtent) {\r\n        ticks.push(roundNumber(niceTickExtent[0] - interval));\r\n      } else {\r\n        ticks.push(extent[0]);\r\n      }\r\n    }\r\n\r\n    var tick = niceTickExtent[0];\r\n\r\n    while (tick <= niceTickExtent[1]) {\r\n      ticks.push(tick); // Avoid rounding error\r\n\r\n      tick = roundNumber(tick + interval, intervalPrecision);\r\n\r\n      if (tick === ticks[ticks.length - 1]) {\r\n        // Consider out of safe float point, e.g.,\r\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\r\n        break;\r\n      }\r\n\r\n      if (ticks.length > safeLimit) {\r\n        return [];\r\n      }\r\n    } // Consider this case: the last item of ticks is smaller\r\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\r\n\r\n\r\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];\r\n\r\n    if (extent[1] > lastNiceTick) {\r\n      if (expandToNicedExtent) {\r\n        ticks.push(lastNiceTick + interval);\r\n      } else {\r\n        ticks.push(extent[1]);\r\n      }\r\n    }\r\n\r\n    return ticks;\r\n  },\r\n\r\n  /**\r\n   * @param {number} [splitNumber=5]\r\n   * @return {Array.<Array.<number>>}\r\n   */\r\n  getMinorTicks: function (splitNumber) {\r\n    var ticks = this.getTicks(true);\r\n    var minorTicks = [];\r\n    var extent = this.getExtent();\r\n\r\n    for (var i = 1; i < ticks.length; i++) {\r\n      var nextTick = ticks[i];\r\n      var prevTick = ticks[i - 1];\r\n      var count = 0;\r\n      var minorTicksGroup = [];\r\n      var interval = nextTick - prevTick;\r\n      var minorInterval = interval / splitNumber;\r\n\r\n      while (count < splitNumber - 1) {\r\n        var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\r\n\r\n        if (minorTick > extent[0] && minorTick < extent[1]) {\r\n          minorTicksGroup.push(minorTick);\r\n        }\r\n\r\n        count++;\r\n      }\r\n\r\n      minorTicks.push(minorTicksGroup);\r\n    }\r\n\r\n    return minorTicks;\r\n  },\r\n\r\n  /**\r\n   * @param {number} data\r\n   * @param {Object} [opt]\r\n   * @param {number|string} [opt.precision] If 'auto', use nice presision.\r\n   * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\r\n   * @return {string}\r\n   */\r\n  getLabel: function (data, opt) {\r\n    if (data == null) {\r\n      return '';\r\n    }\r\n\r\n    var precision = opt && opt.precision;\r\n\r\n    if (precision == null) {\r\n      precision = numberUtil.getPrecisionSafe(data) || 0;\r\n    } else if (precision === 'auto') {\r\n      // Should be more precise then tick.\r\n      precision = this._intervalPrecision;\r\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\r\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\r\n\r\n\r\n    data = roundNumber(data, precision, true);\r\n    return formatUtil.addCommas(data);\r\n  },\r\n\r\n  /**\r\n   * Update interval and extent of intervals for nice ticks\r\n   *\r\n   * @param {number} [splitNumber = 5] Desired number of ticks\r\n   * @param {number} [minInterval]\r\n   * @param {number} [maxInterval]\r\n   */\r\n  niceTicks: function (splitNumber, minInterval, maxInterval) {\r\n    splitNumber = splitNumber || 5;\r\n    var extent = this._extent;\r\n    var span = extent[1] - extent[0];\r\n\r\n    if (!isFinite(span)) {\r\n      return;\r\n    } // User may set axis min 0 and data are all negative\r\n    // FIXME If it needs to reverse ?\r\n\r\n\r\n    if (span < 0) {\r\n      span = -span;\r\n      extent.reverse();\r\n    }\r\n\r\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\r\n    this._intervalPrecision = result.intervalPrecision;\r\n    this._interval = result.interval;\r\n    this._niceExtent = result.niceTickExtent;\r\n  },\r\n\r\n  /**\r\n   * Nice extent.\r\n   * @param {Object} opt\r\n   * @param {number} [opt.splitNumber = 5] Given approx tick number\r\n   * @param {boolean} [opt.fixMin=false]\r\n   * @param {boolean} [opt.fixMax=false]\r\n   * @param {boolean} [opt.minInterval]\r\n   * @param {boolean} [opt.maxInterval]\r\n   */\r\n  niceExtent: function (opt) {\r\n    var extent = this._extent; // If extent start and end are same, expand them\r\n\r\n    if (extent[0] === extent[1]) {\r\n      if (extent[0] !== 0) {\r\n        // Expand extent\r\n        var expandSize = extent[0]; // In the fowllowing case\r\n        //      Axis has been fixed max 100\r\n        //      Plus data are all 100 and axis extent are [100, 100].\r\n        // Extend to the both side will cause expanded max is larger than fixed max.\r\n        // So only expand to the smaller side.\r\n\r\n        if (!opt.fixMax) {\r\n          extent[1] += expandSize / 2;\r\n          extent[0] -= expandSize / 2;\r\n        } else {\r\n          extent[0] -= expandSize / 2;\r\n        }\r\n      } else {\r\n        extent[1] = 1;\r\n      }\r\n    }\r\n\r\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\r\n\r\n    if (!isFinite(span)) {\r\n      extent[0] = 0;\r\n      extent[1] = 1;\r\n    }\r\n\r\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent;\r\n\r\n    var interval = this._interval;\r\n\r\n    if (!opt.fixMin) {\r\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\r\n    }\r\n\r\n    if (!opt.fixMax) {\r\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\r\n    }\r\n  }\r\n});\r\n/**\r\n * @return {module:echarts/scale/Time}\r\n */\r\n\r\nIntervalScale.create = function () {\r\n  return new IntervalScale();\r\n};\r\n\r\nvar _default = IntervalScale;\r\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}