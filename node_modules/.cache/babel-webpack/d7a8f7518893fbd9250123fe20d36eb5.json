{"ast":null,"code":"var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar Text = require(\"../graphic/Text\"); // TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\n\n\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\r\n * PATH\r\n **************************************************/\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\r\n * IMAGE\r\n **************************************************/\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\r\n * TEXT\r\n **************************************************/\n\n\nvar svgText = {};\n\nvar _tmpTextHostRect = new BoundingRect();\n\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\r\n * @param {module:zrender/Element} el\r\n * @param {Object|boolean} [hostRect] {x, y, width, height}\r\n *        If set false, rect text is not used.\r\n */\n\nvar svgTextDrawRectText = function svgTextDrawRectText(el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n\n  if (!textHelper.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n\n    _tmpTextHostRect.applyTransform(elTransform);\n\n    hostRect = _tmpTextHostRect;\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var idx = 0;\n\n    for (; idx < nTextLines; idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[idx];\n      var singleLineText = textLines[idx];\n\n      if (!tspan) {\n        tspan = tspanList[idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__zrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\n    } // Remove unused tspan elements\n\n\n    if (tspanOriginLen > nTextLines) {\n      for (; idx < tspanOriginLen; idx++) {\n        textSvgEl.removeChild(tspanList[idx]);\n      }\n\n      tspanList.length = nTextLines;\n    }\n  }\n};\n\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n\n  var textRotation = style.textRotation;\n\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\n\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    // textSvgEl may has no parentNode if el has been removed temporary.\n    if (el.__textSvgEl.parentNode) {\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n    }\n\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/zrender/lib/svg/graphic.js"],"names":["_core","require","createElement","PathProxy","BoundingRect","matrix","textContain","textHelper","Text","CMD","arrayJoin","Array","prototype","join","NONE","mathRound","Math","round","mathSin","sin","mathCos","cos","PI","PI2","degree","EPSILON","round4","val","isAroundZero","pathHasFill","style","isText","fill","textFill","pathHasStroke","stroke","textStroke","setTransform","svgEl","m","attr","call","el","key","type","setAttribute","attrXLink","setAttributeNS","bindStyle","fillOpacity","opacity","strokeWidth","textStrokeWidth","lineWidth","strokeScale","strokeNoScale","getLineScale","strokeOpacity","lineDash","lineDashOffset","lineCap","lineJoin","miterLimit","pathDataToString","path","str","data","dataLength","len","i","cmd","cmdStr","nData","M","L","Q","C","A","cx","cy","rx","ry","theta","dTheta","psi","clockwise","dThetaPositive","abs","isCircle","unifiedTheta","large","x0","y0","push","x","y","Z","R","w","h","j","svgPath","brush","__svgEl","createPathProxy","__dirtyPath","beginPath","subPixelOptimize","buildPath","shape","pathStr","indexOf","transform","text","svgTextDrawRectText","getBoundingRect","removeOldTextNode","svgImage","image","HTMLImageElement","src","dw","width","dh","height","__imageSrc","svgText","_tmpTextHostRect","_tmpTextBoxPos","_tmpTextTransform","TEXT_ALIGN_TO_ANCHRO","left","right","center","middle","hostRect","elTransform","needTransformTextByHostEl","transformText","__dirty","normalizeTextStyle","needDrawText","copy","applyTransform","textSvgEl","__textSvgEl","textSvgElStyle","font","DEFAULT_FONT","computedFont","__computedFont","__styleFont","textPadding","textLineHeight","contentBlock","__textCotentBlock","__dirtyText","parsePlainText","truncate","outerHeight","lineHeight","getBoxPosition","baseX","baseY","textAlign","textVerticalAlign","setTextTransform","boxY","adjustTextY","textX","textY","getTextXForPadding","canCacheByTextString","tspanList","__tspanList","tspanOriginLen","length","__canCacheByTextString","__text","idx","updateTextLocation","textLines","lines","nTextLines","tspan","singleLineText","appendChild","document","createTextNode","__zrText","innerHTML","removeChild","identity","textRotation","origin","textOrigin","rotate","parentNode","drawRectText","exports"],"mappings":"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","sourcesContent":["var _core = require(\"./core\");\r\n\r\nvar createElement = _core.createElement;\r\n\r\nvar PathProxy = require(\"../core/PathProxy\");\r\n\r\nvar BoundingRect = require(\"../core/BoundingRect\");\r\n\r\nvar matrix = require(\"../core/matrix\");\r\n\r\nvar textContain = require(\"../contain/text\");\r\n\r\nvar textHelper = require(\"../graphic/helper/text\");\r\n\r\nvar Text = require(\"../graphic/Text\");\r\n\r\n// TODO\r\n// 1. shadow\r\n// 2. Image: sx, sy, sw, sh\r\nvar CMD = PathProxy.CMD;\r\nvar arrayJoin = Array.prototype.join;\r\nvar NONE = 'none';\r\nvar mathRound = Math.round;\r\nvar mathSin = Math.sin;\r\nvar mathCos = Math.cos;\r\nvar PI = Math.PI;\r\nvar PI2 = Math.PI * 2;\r\nvar degree = 180 / PI;\r\nvar EPSILON = 1e-4;\r\n\r\nfunction round4(val) {\r\n  return mathRound(val * 1e4) / 1e4;\r\n}\r\n\r\nfunction isAroundZero(val) {\r\n  return val < EPSILON && val > -EPSILON;\r\n}\r\n\r\nfunction pathHasFill(style, isText) {\r\n  var fill = isText ? style.textFill : style.fill;\r\n  return fill != null && fill !== NONE;\r\n}\r\n\r\nfunction pathHasStroke(style, isText) {\r\n  var stroke = isText ? style.textStroke : style.stroke;\r\n  return stroke != null && stroke !== NONE;\r\n}\r\n\r\nfunction setTransform(svgEl, m) {\r\n  if (m) {\r\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\r\n  }\r\n}\r\n\r\nfunction attr(el, key, val) {\r\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\r\n    // Don't set attribute for gradient, since it need new dom nodes\r\n    el.setAttribute(key, val);\r\n  }\r\n}\r\n\r\nfunction attrXLink(el, key, val) {\r\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\r\n}\r\n\r\nfunction bindStyle(svgEl, style, isText, el) {\r\n  if (pathHasFill(style, isText)) {\r\n    var fill = isText ? style.textFill : style.fill;\r\n    fill = fill === 'transparent' ? NONE : fill;\r\n    attr(svgEl, 'fill', fill);\r\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\r\n  } else {\r\n    attr(svgEl, 'fill', NONE);\r\n  }\r\n\r\n  if (pathHasStroke(style, isText)) {\r\n    var stroke = isText ? style.textStroke : style.stroke;\r\n    stroke = stroke === 'transparent' ? NONE : stroke;\r\n    attr(svgEl, 'stroke', stroke);\r\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\r\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\r\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\r\n\r\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\r\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\r\n    var lineDash = style.lineDash;\r\n\r\n    if (lineDash) {\r\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\r\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\r\n    } else {\r\n      attr(svgEl, 'stroke-dasharray', '');\r\n    } // PENDING\r\n\r\n\r\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\r\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\r\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\r\n  } else {\r\n    attr(svgEl, 'stroke', NONE);\r\n  }\r\n}\r\n/***************************************************\r\n * PATH\r\n **************************************************/\r\n\r\n\r\nfunction pathDataToString(path) {\r\n  var str = [];\r\n  var data = path.data;\r\n  var dataLength = path.len();\r\n\r\n  for (var i = 0; i < dataLength;) {\r\n    var cmd = data[i++];\r\n    var cmdStr = '';\r\n    var nData = 0;\r\n\r\n    switch (cmd) {\r\n      case CMD.M:\r\n        cmdStr = 'M';\r\n        nData = 2;\r\n        break;\r\n\r\n      case CMD.L:\r\n        cmdStr = 'L';\r\n        nData = 2;\r\n        break;\r\n\r\n      case CMD.Q:\r\n        cmdStr = 'Q';\r\n        nData = 4;\r\n        break;\r\n\r\n      case CMD.C:\r\n        cmdStr = 'C';\r\n        nData = 6;\r\n        break;\r\n\r\n      case CMD.A:\r\n        var cx = data[i++];\r\n        var cy = data[i++];\r\n        var rx = data[i++];\r\n        var ry = data[i++];\r\n        var theta = data[i++];\r\n        var dTheta = data[i++];\r\n        var psi = data[i++];\r\n        var clockwise = data[i++];\r\n        var dThetaPositive = Math.abs(dTheta);\r\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\r\n\r\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\r\n        var large = false;\r\n\r\n        if (isCircle) {\r\n          large = true;\r\n        } else if (isAroundZero(dThetaPositive)) {\r\n          large = false;\r\n        } else {\r\n          large = unifiedTheta >= PI === !!clockwise;\r\n        }\r\n\r\n        var x0 = round4(cx + rx * mathCos(theta));\r\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\r\n        // We need to shift the end point with a small value\r\n        // FIXME A better way to draw circle ?\r\n\r\n        if (isCircle) {\r\n          if (clockwise) {\r\n            dTheta = PI2 - 1e-4;\r\n          } else {\r\n            dTheta = -PI2 + 1e-4;\r\n          }\r\n\r\n          large = true;\r\n\r\n          if (i === 9) {\r\n            // Move to (x0, y0) only when CMD.A comes at the\r\n            // first position of a shape.\r\n            // For instance, when drawing a ring, CMD.A comes\r\n            // after CMD.M, so it's unnecessary to move to\r\n            // (x0, y0).\r\n            str.push('M', x0, y0);\r\n          }\r\n        }\r\n\r\n        var x = round4(cx + rx * mathCos(theta + dTheta));\r\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\r\n\r\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\r\n        break;\r\n\r\n      case CMD.Z:\r\n        cmdStr = 'Z';\r\n        break;\r\n\r\n      case CMD.R:\r\n        var x = round4(data[i++]);\r\n        var y = round4(data[i++]);\r\n        var w = round4(data[i++]);\r\n        var h = round4(data[i++]);\r\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\r\n        break;\r\n    }\r\n\r\n    cmdStr && str.push(cmdStr);\r\n\r\n    for (var j = 0; j < nData; j++) {\r\n      // PENDING With scale\r\n      str.push(round4(data[i++]));\r\n    }\r\n  }\r\n\r\n  return str.join(' ');\r\n}\r\n\r\nvar svgPath = {};\r\n\r\nsvgPath.brush = function (el) {\r\n  var style = el.style;\r\n  var svgEl = el.__svgEl;\r\n\r\n  if (!svgEl) {\r\n    svgEl = createElement('path');\r\n    el.__svgEl = svgEl;\r\n  }\r\n\r\n  if (!el.path) {\r\n    el.createPathProxy();\r\n  }\r\n\r\n  var path = el.path;\r\n\r\n  if (el.__dirtyPath) {\r\n    path.beginPath();\r\n    path.subPixelOptimize = false;\r\n    el.buildPath(path, el.shape);\r\n    el.__dirtyPath = false;\r\n    var pathStr = pathDataToString(path);\r\n\r\n    if (pathStr.indexOf('NaN') < 0) {\r\n      // Ignore illegal path, which may happen such in out-of-range\r\n      // data in Calendar series.\r\n      attr(svgEl, 'd', pathStr);\r\n    }\r\n  }\r\n\r\n  bindStyle(svgEl, style, false, el);\r\n  setTransform(svgEl, el.transform);\r\n\r\n  if (style.text != null) {\r\n    svgTextDrawRectText(el, el.getBoundingRect());\r\n  } else {\r\n    removeOldTextNode(el);\r\n  }\r\n};\r\n/***************************************************\r\n * IMAGE\r\n **************************************************/\r\n\r\n\r\nvar svgImage = {};\r\n\r\nsvgImage.brush = function (el) {\r\n  var style = el.style;\r\n  var image = style.image;\r\n\r\n  if (image instanceof HTMLImageElement) {\r\n    var src = image.src;\r\n    image = src;\r\n  }\r\n\r\n  if (!image) {\r\n    return;\r\n  }\r\n\r\n  var x = style.x || 0;\r\n  var y = style.y || 0;\r\n  var dw = style.width;\r\n  var dh = style.height;\r\n  var svgEl = el.__svgEl;\r\n\r\n  if (!svgEl) {\r\n    svgEl = createElement('image');\r\n    el.__svgEl = svgEl;\r\n  }\r\n\r\n  if (image !== el.__imageSrc) {\r\n    attrXLink(svgEl, 'href', image); // Caching image src\r\n\r\n    el.__imageSrc = image;\r\n  }\r\n\r\n  attr(svgEl, 'width', dw);\r\n  attr(svgEl, 'height', dh);\r\n  attr(svgEl, 'x', x);\r\n  attr(svgEl, 'y', y);\r\n  setTransform(svgEl, el.transform);\r\n\r\n  if (style.text != null) {\r\n    svgTextDrawRectText(el, el.getBoundingRect());\r\n  } else {\r\n    removeOldTextNode(el);\r\n  }\r\n};\r\n/***************************************************\r\n * TEXT\r\n **************************************************/\r\n\r\n\r\nvar svgText = {};\r\n\r\nvar _tmpTextHostRect = new BoundingRect();\r\n\r\nvar _tmpTextBoxPos = {};\r\nvar _tmpTextTransform = [];\r\nvar TEXT_ALIGN_TO_ANCHRO = {\r\n  left: 'start',\r\n  right: 'end',\r\n  center: 'middle',\r\n  middle: 'middle'\r\n};\r\n/**\r\n * @param {module:zrender/Element} el\r\n * @param {Object|boolean} [hostRect] {x, y, width, height}\r\n *        If set false, rect text is not used.\r\n */\r\n\r\nvar svgTextDrawRectText = function (el, hostRect) {\r\n  var style = el.style;\r\n  var elTransform = el.transform;\r\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\r\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\r\n  var text = style.text; // Convert to string\r\n\r\n  text != null && (text += '');\r\n\r\n  if (!textHelper.needDrawText(text, style)) {\r\n    return;\r\n  } // render empty text for svg if no text but need draw text.\r\n\r\n\r\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\r\n  // text, transform the hostRect, by which the text is located.\r\n\r\n  if (!needTransformTextByHostEl && elTransform) {\r\n    _tmpTextHostRect.copy(hostRect);\r\n\r\n    _tmpTextHostRect.applyTransform(elTransform);\r\n\r\n    hostRect = _tmpTextHostRect;\r\n  }\r\n\r\n  var textSvgEl = el.__textSvgEl;\r\n\r\n  if (!textSvgEl) {\r\n    textSvgEl = createElement('text');\r\n    el.__textSvgEl = textSvgEl;\r\n  } // style.font has been normalized by `normalizeTextStyle`.\r\n\r\n\r\n  var textSvgElStyle = textSvgEl.style;\r\n  var font = style.font || textContain.DEFAULT_FONT;\r\n  var computedFont = textSvgEl.__computedFont;\r\n\r\n  if (font !== textSvgEl.__styleFont) {\r\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\r\n\r\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\r\n  }\r\n\r\n  var textPadding = style.textPadding;\r\n  var textLineHeight = style.textLineHeight;\r\n  var contentBlock = el.__textCotentBlock;\r\n\r\n  if (!contentBlock || el.__dirtyText) {\r\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\r\n  }\r\n\r\n  var outerHeight = contentBlock.outerHeight;\r\n  var lineHeight = contentBlock.lineHeight;\r\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\r\n  var baseX = _tmpTextBoxPos.baseX;\r\n  var baseY = _tmpTextBoxPos.baseY;\r\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\r\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\r\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\r\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\r\n  var textX = baseX;\r\n  var textY = boxY; // TODO needDrawBg\r\n\r\n  if (textPadding) {\r\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\r\n    textY += textPadding[0];\r\n  } // `textBaseline` is set as 'middle'.\r\n\r\n\r\n  textY += lineHeight / 2;\r\n  bindStyle(textSvgEl, style, true, el); // FIXME\r\n  // Add a <style> to reset all of the text font as inherit?\r\n  // otherwise the outer <style> may set the unexpected style.\r\n  // Font may affect position of each tspan elements\r\n\r\n  var canCacheByTextString = contentBlock.canCacheByTextString;\r\n  var tspanList = el.__tspanList || (el.__tspanList = []);\r\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\r\n\r\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\r\n    if (el.__dirtyText && tspanOriginLen) {\r\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\r\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\r\n      }\r\n    }\r\n  } else {\r\n    el.__text = text;\r\n    el.__canCacheByTextString = canCacheByTextString;\r\n    var textLines = contentBlock.lines;\r\n    var nTextLines = textLines.length;\r\n    var idx = 0;\r\n\r\n    for (; idx < nTextLines; idx++) {\r\n      // Using cached tspan elements\r\n      var tspan = tspanList[idx];\r\n      var singleLineText = textLines[idx];\r\n\r\n      if (!tspan) {\r\n        tspan = tspanList[idx] = createElement('tspan');\r\n        textSvgEl.appendChild(tspan);\r\n        tspan.appendChild(document.createTextNode(singleLineText));\r\n      } else if (tspan.__zrText !== singleLineText) {\r\n        tspan.innerHTML = '';\r\n        tspan.appendChild(document.createTextNode(singleLineText));\r\n      }\r\n\r\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\r\n    } // Remove unused tspan elements\r\n\r\n\r\n    if (tspanOriginLen > nTextLines) {\r\n      for (; idx < tspanOriginLen; idx++) {\r\n        textSvgEl.removeChild(tspanList[idx]);\r\n      }\r\n\r\n      tspanList.length = nTextLines;\r\n    }\r\n  }\r\n};\r\n\r\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\r\n  matrix.identity(_tmpTextTransform);\r\n\r\n  if (needTransformTextByHostEl && elTransform) {\r\n    matrix.copy(_tmpTextTransform, elTransform);\r\n  } // textRotation only apply in RectText.\r\n\r\n\r\n  var textRotation = style.textRotation;\r\n\r\n  if (hostRect && textRotation) {\r\n    var origin = style.textOrigin;\r\n\r\n    if (origin === 'center') {\r\n      baseX = hostRect.width / 2 + hostRect.x;\r\n      baseY = hostRect.height / 2 + hostRect.y;\r\n    } else if (origin) {\r\n      baseX = origin[0] + hostRect.x;\r\n      baseY = origin[1] + hostRect.y;\r\n    }\r\n\r\n    _tmpTextTransform[4] -= baseX;\r\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\r\n\r\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\r\n    _tmpTextTransform[4] += baseX;\r\n    _tmpTextTransform[5] += baseY;\r\n  } // See the definition in `Style.js#textOrigin`, the default\r\n  // origin is from the result of `getBoxPosition`.\r\n\r\n\r\n  setTransform(textSvgEl, _tmpTextTransform);\r\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\r\n\r\n\r\nfunction getTextXForPadding(x, textAlign, textPadding) {\r\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\r\n}\r\n\r\nfunction updateTextLocation(tspan, textAlign, x, y) {\r\n  // Consider different font display differently in vertial align, we always\r\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\r\n  attr(tspan, 'dominant-baseline', 'middle');\r\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\r\n  attr(tspan, 'x', x);\r\n  attr(tspan, 'y', y);\r\n}\r\n\r\nfunction removeOldTextNode(el) {\r\n  if (el && el.__textSvgEl) {\r\n    // textSvgEl may has no parentNode if el has been removed temporary.\r\n    if (el.__textSvgEl.parentNode) {\r\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\r\n    }\r\n\r\n    el.__textSvgEl = null;\r\n    el.__tspanList = [];\r\n    el.__text = null;\r\n  }\r\n}\r\n\r\nsvgText.drawRectText = svgTextDrawRectText;\r\n\r\nsvgText.brush = function (el) {\r\n  var style = el.style;\r\n\r\n  if (style.text != null) {\r\n    svgTextDrawRectText(el, false);\r\n  } else {\r\n    removeOldTextNode(el);\r\n  }\r\n};\r\n\r\nexports.path = svgPath;\r\nexports.image = svgImage;\r\nexports.text = svgText;"]},"metadata":{},"sourceType":"script"}