{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar ComponentModel = require(\"./Component\");\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * ECharts option manager\r\n *\r\n * @module {echarts/model/OptionManager}\r\n */\n\n\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\r\n * TERM EXPLANATIONS:\r\n *\r\n * [option]:\r\n *\r\n *     An object that contains definitions of components. For example:\r\n *     var option = {\r\n *         title: {...},\r\n *         legend: {...},\r\n *         visualMap: {...},\r\n *         series: [\r\n *             {data: [...]},\r\n *             {data: [...]},\r\n *             ...\r\n *         ]\r\n *     };\r\n *\r\n * [rawOption]:\r\n *\r\n *     An object input to echarts.setOption. 'rawOption' may be an\r\n *     'option', or may be an object contains multi-options. For example:\r\n *     var option = {\r\n *         baseOption: {\r\n *             title: {...},\r\n *             legend: {...},\r\n *             series: [\r\n *                 {data: [...]},\r\n *                 {data: [...]},\r\n *                 ...\r\n *             ]\r\n *         },\r\n *         timeline: {...},\r\n *         options: [\r\n *             {title: {...}, series: {data: [...]}},\r\n *             {title: {...}, series: {data: [...]}},\r\n *             ...\r\n *         ],\r\n *         media: [\r\n *             {\r\n *                 query: {maxWidth: 320},\r\n *                 option: {series: {x: 20}, visualMap: {show: false}}\r\n *             },\r\n *             {\r\n *                 query: {minWidth: 320, maxWidth: 720},\r\n *                 option: {series: {x: 500}, visualMap: {show: true}}\r\n *             },\r\n *             {\r\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\r\n *             }\r\n *         ]\r\n *     };\r\n *\r\n * @alias module:echarts/model/OptionManager\r\n * @param {module:echarts/ExtensionAPI} api\r\n */\n\nfunction OptionManager(api) {\n  /**\r\n   * @private\r\n   * @type {module:echarts/ExtensionAPI}\r\n   */\n  this._api = api;\n  /**\r\n   * @private\r\n   * @type {Array.<number>}\r\n   */\n\n  this._timelineOptions = [];\n  /**\r\n   * @private\r\n   * @type {Array.<Object>}\r\n   */\n\n  this._mediaList = [];\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._mediaDefault;\n  /**\r\n   * -1, means default.\r\n   * empty means no media.\r\n   * @private\r\n   * @type {Array.<number>}\r\n   */\n\n  this._currentMediaIndices = [];\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._optionBackup;\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\r\n   * @public\r\n   * @param {Object} rawOption Raw option.\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @param {Array.<Function>} optionPreprocessorFuncs\r\n   * @return {Object} Init option\r\n   */\n  setOption: function setOption(rawOption, optionPreprocessorFuncs) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function (series) {\n        series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);\n      });\n    } // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n\n\n    rawOption = clone(rawOption); // FIXME\n    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\r\n   * @param {boolean} isRecreate\r\n   * @return {Object}\r\n   */\n  mountOption: function mountOption(isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // 如果没有reset功能则不clone。\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @return {Object}\r\n   */\n  getTimelineOption: function getTimelineOption(ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @return {Array.<Object>}\r\n   */\n  getMediaOption: function getMediaOption(ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\r\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\r\n * Support: width, height, aspectRatio\r\n * Can use max or min as prefix.\r\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\r\n * Consider case:\r\n * `chart.setOption(opt1);`\r\n * Then user do some interaction like dataZoom, dataView changing.\r\n * `chart.setOption(opt2);`\r\n * Then user press 'reset button' in toolbox.\r\n *\r\n * After doing that all of the interaction effects should be reset, the\r\n * chart should be the same as the result of invoke\r\n * `chart.setOption(opt1); chart.setOption(opt2);`.\r\n *\r\n * Although it is not able ensure that\r\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\r\n * `chart.setOption(merge(opt1, opt2));` exactly,\r\n * this might be the only simple way to implement that feature.\r\n *\r\n * MEMO: We've considered some other approaches:\r\n * 1. Each model handle its self restoration but not uniform treatment.\r\n *     (Too complex in logic and error-prone)\r\n * 2. Use a shadow ecModel. (Performace expensive)\r\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/echarts/lib/model/OptionManager.js"],"names":["zrUtil","require","modelUtil","ComponentModel","each","clone","map","merge","QUERY_REG","OptionManager","api","_api","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","prototype","constructor","setOption","rawOption","optionPreprocessorFuncs","normalizeToArray","series","data","isTypedArray","setAsPrimitive","oldOptionBackup","newParsedOption","parseRawOption","call","baseOption","mergeOption","timelineOptions","length","mediaList","mediaDefault","mountOption","isRecreate","optionBackup","getTimelineOption","ecModel","option","timelineModel","getComponent","getCurrentIndex","getMediaOption","ecWidth","getWidth","ecHeight","getHeight","indices","result","i","len","applyMediaQuery","query","push","indicesEquals","index","isNew","timelineOpt","timeline","options","slice","media","singleMedia","concat","preProcess","realMap","width","height","aspectratio","applicatable","value","attr","matched","match","operator","realAttr","toLowerCase","compare","real","expect","indices1","indices2","join","oldOption","newOption","newCptOpt","mainType","oldCptOpt","hasClass","mapResult","mappingToExists","item","exist","_default","module","exports"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,eAAD,CAAvB;;AAEA,IAAIE,cAAc,GAAGF,OAAO,CAAC,aAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAIG,IAAI,GAAGJ,MAAM,CAACI,IAAlB;AACA,IAAIC,KAAK,GAAGL,MAAM,CAACK,KAAnB;AACA,IAAIC,GAAG,GAAGN,MAAM,CAACM,GAAjB;AACA,IAAIC,KAAK,GAAGP,MAAM,CAACO,KAAnB;AACA,IAAIC,SAAS,GAAG,kBAAhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;AAC1B;AACF;AACA;AACA;AACE,OAAKC,IAAL,GAAYD,GAAZ;AACA;AACF;AACA;AACA;;AAEE,OAAKE,gBAAL,GAAwB,EAAxB;AACA;AACF;AACA;AACA;;AAEE,OAAKC,UAAL,GAAkB,EAAlB;AACA;AACF;AACA;AACA;;AAEE,OAAKC,aAAL;AACA;AACF;AACA;AACA;AACA;AACA;;AAEE,OAAKC,oBAAL,GAA4B,EAA5B;AACA;AACF;AACA;AACA;;AAEE,OAAKC,aAAL;AACA;AACF;AACA;AACA;;AAEE,OAAKC,cAAL;AACD,C,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nvar zrUtil = require(\"zrender/lib/core/util\");\r\n\r\nvar modelUtil = require(\"../util/model\");\r\n\r\nvar ComponentModel = require(\"./Component\");\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n/**\r\n * ECharts option manager\r\n *\r\n * @module {echarts/model/OptionManager}\r\n */\r\nvar each = zrUtil.each;\r\nvar clone = zrUtil.clone;\r\nvar map = zrUtil.map;\r\nvar merge = zrUtil.merge;\r\nvar QUERY_REG = /^(min|max)?(.+)$/;\r\n/**\r\n * TERM EXPLANATIONS:\r\n *\r\n * [option]:\r\n *\r\n *     An object that contains definitions of components. For example:\r\n *     var option = {\r\n *         title: {...},\r\n *         legend: {...},\r\n *         visualMap: {...},\r\n *         series: [\r\n *             {data: [...]},\r\n *             {data: [...]},\r\n *             ...\r\n *         ]\r\n *     };\r\n *\r\n * [rawOption]:\r\n *\r\n *     An object input to echarts.setOption. 'rawOption' may be an\r\n *     'option', or may be an object contains multi-options. For example:\r\n *     var option = {\r\n *         baseOption: {\r\n *             title: {...},\r\n *             legend: {...},\r\n *             series: [\r\n *                 {data: [...]},\r\n *                 {data: [...]},\r\n *                 ...\r\n *             ]\r\n *         },\r\n *         timeline: {...},\r\n *         options: [\r\n *             {title: {...}, series: {data: [...]}},\r\n *             {title: {...}, series: {data: [...]}},\r\n *             ...\r\n *         ],\r\n *         media: [\r\n *             {\r\n *                 query: {maxWidth: 320},\r\n *                 option: {series: {x: 20}, visualMap: {show: false}}\r\n *             },\r\n *             {\r\n *                 query: {minWidth: 320, maxWidth: 720},\r\n *                 option: {series: {x: 500}, visualMap: {show: true}}\r\n *             },\r\n *             {\r\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\r\n *             }\r\n *         ]\r\n *     };\r\n *\r\n * @alias module:echarts/model/OptionManager\r\n * @param {module:echarts/ExtensionAPI} api\r\n */\r\n\r\nfunction OptionManager(api) {\r\n  /**\r\n   * @private\r\n   * @type {module:echarts/ExtensionAPI}\r\n   */\r\n  this._api = api;\r\n  /**\r\n   * @private\r\n   * @type {Array.<number>}\r\n   */\r\n\r\n  this._timelineOptions = [];\r\n  /**\r\n   * @private\r\n   * @type {Array.<Object>}\r\n   */\r\n\r\n  this._mediaList = [];\r\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\r\n\r\n  this._mediaDefault;\r\n  /**\r\n   * -1, means default.\r\n   * empty means no media.\r\n   * @private\r\n   * @type {Array.<number>}\r\n   */\r\n\r\n  this._currentMediaIndices = [];\r\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\r\n\r\n  this._optionBackup;\r\n  /**\r\n   * @private\r\n   * @type {Object}\r\n   */\r\n\r\n  this._newBaseOption;\r\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\r\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\r\n// rawOption cloned and backuped when timeline changed, which does no\r\n// good to performance. What's more, that both timeline and setOption\r\n// method supply 'notMerge' brings complex and some problems.\r\n// Consider this case:\r\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\r\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\r\n\r\n\r\nOptionManager.prototype = {\r\n  constructor: OptionManager,\r\n\r\n  /**\r\n   * @public\r\n   * @param {Object} rawOption Raw option.\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @param {Array.<Function>} optionPreprocessorFuncs\r\n   * @return {Object} Init option\r\n   */\r\n  setOption: function (rawOption, optionPreprocessorFuncs) {\r\n    if (rawOption) {\r\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\r\n      zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function (series) {\r\n        series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);\r\n      });\r\n    } // Caution: some series modify option data, if do not clone,\r\n    // it should ensure that the repeat modify correctly\r\n    // (create a new object when modify itself).\r\n\r\n\r\n    rawOption = clone(rawOption); // FIXME\r\n    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\r\n\r\n    var oldOptionBackup = this._optionBackup;\r\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\r\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\r\n\r\n    if (oldOptionBackup) {\r\n      // Only baseOption can be merged.\r\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\r\n      // that is, if you `setOption` twice and both has timeline options, the latter\r\n      // timeline opitons will not be merged to the formers, but just substitude them.\r\n\r\n      if (newParsedOption.timelineOptions.length) {\r\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\r\n      }\r\n\r\n      if (newParsedOption.mediaList.length) {\r\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\r\n      }\r\n\r\n      if (newParsedOption.mediaDefault) {\r\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\r\n      }\r\n    } else {\r\n      this._optionBackup = newParsedOption;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @param {boolean} isRecreate\r\n   * @return {Object}\r\n   */\r\n  mountOption: function (isRecreate) {\r\n    var optionBackup = this._optionBackup; // TODO\r\n    // 如果没有reset功能则不clone。\r\n\r\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\r\n    this._mediaList = map(optionBackup.mediaList, clone);\r\n    this._mediaDefault = clone(optionBackup.mediaDefault);\r\n    this._currentMediaIndices = [];\r\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\r\n    // called, and is merged into every new option by inner method `mergeOption`\r\n    // each time `setOption` called, can be only used in `isRecreate`, because\r\n    // its reliability is under suspicion. In other cases option merge is\r\n    // performed by `model.mergeOption`.\r\n    ? optionBackup.baseOption : this._newBaseOption);\r\n  },\r\n\r\n  /**\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @return {Object}\r\n   */\r\n  getTimelineOption: function (ecModel) {\r\n    var option;\r\n    var timelineOptions = this._timelineOptions;\r\n\r\n    if (timelineOptions.length) {\r\n      // getTimelineOption can only be called after ecModel inited,\r\n      // so we can get currentIndex from timelineModel.\r\n      var timelineModel = ecModel.getComponent('timeline');\r\n\r\n      if (timelineModel) {\r\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\r\n      }\r\n    }\r\n\r\n    return option;\r\n  },\r\n\r\n  /**\r\n   * @param {module:echarts/model/Global} ecModel\r\n   * @return {Array.<Object>}\r\n   */\r\n  getMediaOption: function (ecModel) {\r\n    var ecWidth = this._api.getWidth();\r\n\r\n    var ecHeight = this._api.getHeight();\r\n\r\n    var mediaList = this._mediaList;\r\n    var mediaDefault = this._mediaDefault;\r\n    var indices = [];\r\n    var result = []; // No media defined.\r\n\r\n    if (!mediaList.length && !mediaDefault) {\r\n      return result;\r\n    } // Multi media may be applied, the latter defined media has higher priority.\r\n\r\n\r\n    for (var i = 0, len = mediaList.length; i < len; i++) {\r\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\r\n        indices.push(i);\r\n      }\r\n    } // FIXME\r\n    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\r\n\r\n\r\n    if (!indices.length && mediaDefault) {\r\n      indices = [-1];\r\n    }\r\n\r\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\r\n      result = map(indices, function (index) {\r\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\r\n      });\r\n    } // Otherwise return nothing.\r\n\r\n\r\n    this._currentMediaIndices = indices;\r\n    return result;\r\n  }\r\n};\r\n\r\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\r\n  var timelineOptions = [];\r\n  var mediaList = [];\r\n  var mediaDefault;\r\n  var baseOption; // Compatible with ec2.\r\n\r\n  var timelineOpt = rawOption.timeline;\r\n\r\n  if (rawOption.baseOption) {\r\n    baseOption = rawOption.baseOption;\r\n  } // For timeline\r\n\r\n\r\n  if (timelineOpt || rawOption.options) {\r\n    baseOption = baseOption || {};\r\n    timelineOptions = (rawOption.options || []).slice();\r\n  } // For media query\r\n\r\n\r\n  if (rawOption.media) {\r\n    baseOption = baseOption || {};\r\n    var media = rawOption.media;\r\n    each(media, function (singleMedia) {\r\n      if (singleMedia && singleMedia.option) {\r\n        if (singleMedia.query) {\r\n          mediaList.push(singleMedia);\r\n        } else if (!mediaDefault) {\r\n          // Use the first media default.\r\n          mediaDefault = singleMedia;\r\n        }\r\n      }\r\n    });\r\n  } // For normal option\r\n\r\n\r\n  if (!baseOption) {\r\n    baseOption = rawOption;\r\n  } // Set timelineOpt to baseOption in ec3,\r\n  // which is convenient for merge option.\r\n\r\n\r\n  if (!baseOption.timeline) {\r\n    baseOption.timeline = timelineOpt;\r\n  } // Preprocess.\r\n\r\n\r\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\r\n    return media.option;\r\n  })), function (option) {\r\n    each(optionPreprocessorFuncs, function (preProcess) {\r\n      preProcess(option, isNew);\r\n    });\r\n  });\r\n  return {\r\n    baseOption: baseOption,\r\n    timelineOptions: timelineOptions,\r\n    mediaDefault: mediaDefault,\r\n    mediaList: mediaList\r\n  };\r\n}\r\n/**\r\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\r\n * Support: width, height, aspectRatio\r\n * Can use max or min as prefix.\r\n */\r\n\r\n\r\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\r\n  var realMap = {\r\n    width: ecWidth,\r\n    height: ecHeight,\r\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\r\n\r\n  };\r\n  var applicatable = true;\r\n  zrUtil.each(query, function (value, attr) {\r\n    var matched = attr.match(QUERY_REG);\r\n\r\n    if (!matched || !matched[1] || !matched[2]) {\r\n      return;\r\n    }\r\n\r\n    var operator = matched[1];\r\n    var realAttr = matched[2].toLowerCase();\r\n\r\n    if (!compare(realMap[realAttr], value, operator)) {\r\n      applicatable = false;\r\n    }\r\n  });\r\n  return applicatable;\r\n}\r\n\r\nfunction compare(real, expect, operator) {\r\n  if (operator === 'min') {\r\n    return real >= expect;\r\n  } else if (operator === 'max') {\r\n    return real <= expect;\r\n  } else {\r\n    // Equals\r\n    return real === expect;\r\n  }\r\n}\r\n\r\nfunction indicesEquals(indices1, indices2) {\r\n  // indices is always order by asc and has only finite number.\r\n  return indices1.join(',') === indices2.join(',');\r\n}\r\n/**\r\n * Consider case:\r\n * `chart.setOption(opt1);`\r\n * Then user do some interaction like dataZoom, dataView changing.\r\n * `chart.setOption(opt2);`\r\n * Then user press 'reset button' in toolbox.\r\n *\r\n * After doing that all of the interaction effects should be reset, the\r\n * chart should be the same as the result of invoke\r\n * `chart.setOption(opt1); chart.setOption(opt2);`.\r\n *\r\n * Although it is not able ensure that\r\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\r\n * `chart.setOption(merge(opt1, opt2));` exactly,\r\n * this might be the only simple way to implement that feature.\r\n *\r\n * MEMO: We've considered some other approaches:\r\n * 1. Each model handle its self restoration but not uniform treatment.\r\n *     (Too complex in logic and error-prone)\r\n * 2. Use a shadow ecModel. (Performace expensive)\r\n */\r\n\r\n\r\nfunction mergeOption(oldOption, newOption) {\r\n  newOption = newOption || {};\r\n  each(newOption, function (newCptOpt, mainType) {\r\n    if (newCptOpt == null) {\r\n      return;\r\n    }\r\n\r\n    var oldCptOpt = oldOption[mainType];\r\n\r\n    if (!ComponentModel.hasClass(mainType)) {\r\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\r\n    } else {\r\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\r\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\r\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\r\n      oldOption[mainType] = map(mapResult, function (item) {\r\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nvar _default = OptionManager;\r\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}