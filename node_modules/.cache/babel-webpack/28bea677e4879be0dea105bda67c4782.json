{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar filter = _util.filter;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar indexOf = _util.indexOf;\nvar isObject = _util.isObject;\nvar isString = _util.isString;\nvar createHashMap = _util.createHashMap;\nvar assert = _util.assert;\nvar clone = _util.clone;\nvar merge = _util.merge;\nvar extend = _util.extend;\nvar mixin = _util.mixin;\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\n\nvar _sourceHelper = require(\"../data/helper/sourceHelper\");\n\nvar resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n/**\r\n * ECharts global model\r\n *\r\n * @module {echarts/model/Global}\r\n */\n\n/**\r\n * Caution: If the mechanism should be changed some day, these cases\r\n * should be considered:\r\n *\r\n * (1) In `merge option` mode, if using the same option to call `setOption`\r\n * many times, the result should be the same (try our best to ensure that).\r\n * (2) In `merge option` mode, if a component has no id/name specified, it\r\n * will be merged by index, and the result sequence of the components is\r\n * consistent to the original sequence.\r\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\r\n * `mergeOption` in module:echarts/model/OptionManager.\r\n */\n\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\r\n * @alias module:echarts/model/Global\r\n *\r\n * @param {Object} option\r\n * @param {module:echarts/model/Model} parentModel\r\n * @param {Object} theme\r\n */\n\nvar GlobalModel = Model.extend({\n  init: function init(option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\r\n     * @type {module:echarts/model/Model}\r\n     * @private\r\n     */\n\n    this._theme = new Model(theme);\n    /**\r\n     * @type {module:echarts/model/OptionManager}\r\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function setOption(option, optionPreprocessorFuncs) {\n    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\r\n   * @param {string} type null/undefined: reset all.\r\n   *                      'recreate': force recreate all.\r\n   *                      'timeline': only reset timeline option\r\n   *                      'media': only reset media query option\r\n   * @return {boolean} Whether option changed.\r\n   */\n  resetOption: function resetOption(type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\r\n   * @protected\r\n   */\n  mergeOption: function mergeOption(newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = [];\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCptTypes.push(mainType);\n      }\n    });\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        createSeriesIndices(this, componentsMap.get('series'));\n      }\n    }\n\n    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);\n  },\n\n  /**\r\n   * Get option for output (cloned option and inner info removed)\r\n   * @public\r\n   * @return {Object}\r\n   */\n  getOption: function getOption() {\n    var option = clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\r\n   * @return {module:echarts/model/Model}\r\n   */\n  getTheme: function getTheme() {\n    return this._theme;\n  },\n\n  /**\r\n   * @param {string} mainType\r\n   * @param {number} [idx=0]\r\n   * @return {module:echarts/model/Component}\r\n   */\n  getComponent: function getComponent(mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\r\n   * If none of index and id and name used, return all components with mainType.\r\n   * @param {Object} condition\r\n   * @param {string} condition.mainType\r\n   * @param {string} [condition.subType] If ignore, only query by mainType\r\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\r\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\r\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\r\n   * @return {Array.<module:echarts/model/Component>}\r\n   */\n  queryComponents: function queryComponents(condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\r\n   * The interface is different from queryComponents,\r\n   * which is convenient for inner usage.\r\n   *\r\n   * @usage\r\n   * var result = findComponents(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\r\n   * );\r\n   * var result = findComponents(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\r\n   * );\r\n   * var result = findComponents(\r\n   *     {mainType: 'series',\r\n   *     filter: function (model, index) {...}}\r\n   * );\r\n   * // result like [component0, componnet1, ...]\r\n   *\r\n   * @param {Object} condition\r\n   * @param {string} condition.mainType Mandatory.\r\n   * @param {string} [condition.subType] Optional.\r\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\r\n   *        where xxx is mainType.\r\n   *        If query attribute is null/undefined or has no index/id/name,\r\n   *        do not filtering by query conditions, which is convenient for\r\n   *        no-payload situations or when target of action is global.\r\n   * @param {Function} [condition.filter] parameter: component, return boolean.\r\n   * @return {Array.<module:echarts/model/Component>}\r\n   */\n  findComponents: function findComponents(condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\r\n   * @usage\r\n   * eachComponent('legend', function (legendModel, index) {\r\n   *     ...\r\n   * });\r\n   * eachComponent(function (componentType, model, index) {\r\n   *     // componentType does not include subType\r\n   *     // (componentType is 'xxx' but not 'xxx.aa')\r\n   * });\r\n   * eachComponent(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\r\n   *     function (model, index) {...}\r\n   * );\r\n   * eachComponent(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\r\n   *     function (model, index) {...}\r\n   * );\r\n   *\r\n   * @param {string|Object=} mainType When mainType is object, the definition\r\n   *                                  is the same as the method 'findComponents'.\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  eachComponent: function eachComponent(mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\r\n   * @param {string} name\r\n   * @return {Array.<module:echarts/model/Series>}\r\n   */\n  getSeriesByName: function getSeriesByName(name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\r\n   * @param {number} seriesIndex\r\n   * @return {module:echarts/model/Series}\r\n   */\n  getSeriesByIndex: function getSeriesByIndex(seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\r\n   * Get series list before filtered by type.\r\n   * FIXME: rename to getRawSeriesByType?\r\n   *\r\n   * @param {string} subType\r\n   * @return {Array.<module:echarts/model/Series>}\r\n   */\n  getSeriesByType: function getSeriesByType(subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\r\n   * @return {Array.<module:echarts/model/Series>}\r\n   */\n  getSeries: function getSeries() {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\r\n   * @return {number}\r\n   */\n  getSeriesCount: function getSeriesCount() {\n    return this._componentsMap.get('series').length;\n  },\n\n  /**\r\n   * After filtering, series may be different\r\n   * frome raw series.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  eachSeries: function eachSeries(cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\r\n   * Iterate raw series before filtered.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  eachRawSeries: function eachRawSeries(cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\r\n   * After filtering, series may be different.\r\n   * frome raw series.\r\n   *\r\n   * @param {string} subType.\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  eachSeriesByType: function eachSeriesByType(subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\r\n   * Iterate raw series before filtered of given type.\r\n   *\r\n   * @parma {string} subType\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  eachRawSeriesByType: function eachRawSeriesByType(subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\r\n   * @param {module:echarts/model/Series} seriesModel\r\n   */\n  isSeriesFiltered: function isSeriesFiltered(seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  },\n\n  /**\r\n   * @return {Array.<number>}\r\n   */\n  getCurrentSeriesIndices: function getCurrentSeriesIndices() {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\n  filterSeries: function filterSeries(cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    createSeriesIndices(this, filteredSeries);\n  },\n  restoreData: function restoreData(payload) {\n    var componentsMap = this._componentsMap;\n    createSeriesIndices(this, componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();\n      });\n    });\n  }\n});\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seiresIndex;\n    var id = payload.seriesId;\n    var name = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;\n  }\n}\n/**\r\n * @inner\r\n */\n\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\r\n   * Init with series: [], in case of calling findSeries method\r\n   * before series initialized.\r\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\r\n   * @private\r\n   */\n\n  this._componentsMap = createHashMap({\n    series: []\n  });\n  /**\r\n   * Mapping between filtered series list and raw series list.\r\n   * key: filtered series indices, value: raw series indices.\r\n   * @type {Array.<nubmer>}\r\n   * @private\r\n   */\n\n  this._seriesIndices;\n  this._seriesIndicesMap;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\r\n * @inner\r\n * @param {Array.<string>|string} types model types\r\n * @return {Object} key: {string} type, value: {Array.<Object>} models\r\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\r\n * @inner\r\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\r\n * @inner\r\n */\n\n\nfunction createSeriesIndices(ecModel, seriesModels) {\n  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || []);\n}\n/**\r\n * @inner\r\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\r\n * @inner\r\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nmixin(GlobalModel, colorPaletteMixin);\nvar _default = GlobalModel;\nmodule.exports = _default;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/echarts/lib/model/Global.js"],"names":["_config","require","__DEV__","_util","each","filter","map","isArray","indexOf","isObject","isString","createHashMap","assert","clone","merge","extend","mixin","modelUtil","Model","ComponentModel","globalDefault","colorPaletteMixin","_sourceHelper","resetSourceDefaulter","OPTION_INNER_KEY","GlobalModel","init","option","parentModel","theme","optionManager","_theme","_optionManager","setOption","optionPreprocessorFuncs","resetOption","type","optionChanged","baseOption","mountOption","initBase","call","restoreData","mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","_api","length","mediaOption","newOption","componentsMap","_componentsMap","newCptTypes","componentOption","mainType","hasClass","push","topologicalTravel","getAllClassMainTypes","visitComponent","dependencies","newCptOptionList","normalizeToArray","mapResult","mappingToExists","get","makeIdAndName","item","index","opt","keyInfo","subType","determineSubType","exist","dependentModels","getComponentsByTypes","set","resultItem","componentModel","newCptOption","optionUpdated","ComponentModelClass","getClass","constructor","name","extraOpt","componentIndex","createSeriesIndices","_seriesIndicesMap","_seriesIndices","getOption","opts","i","isIdInner","splice","getTheme","getComponent","idx","list","queryComponents","condition","id","cpts","result","val","isIdArray","cpt","isNameArray","slice","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","components","componentType","component","queryResult","getSeriesByName","series","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","getSeriesCount","eachSeries","assertSeriesInitialized","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","getCurrentSeriesIndices","filterSeries","filteredSeries","payload","componentTypes","isNotTargetSeries","seiresIndex","seriesId","seriesName","mergeTheme","notMergeColorLayer","color","colorLayer","themeItem","types","ret","existComponent","ecModel","seriesModels","hasOwnProperty","_default","module","exports"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nvar _config = require(\"../config\");\r\n\r\nvar __DEV__ = _config.__DEV__;\r\n\r\nvar _util = require(\"zrender/lib/core/util\");\r\n\r\nvar each = _util.each;\r\nvar filter = _util.filter;\r\nvar map = _util.map;\r\nvar isArray = _util.isArray;\r\nvar indexOf = _util.indexOf;\r\nvar isObject = _util.isObject;\r\nvar isString = _util.isString;\r\nvar createHashMap = _util.createHashMap;\r\nvar assert = _util.assert;\r\nvar clone = _util.clone;\r\nvar merge = _util.merge;\r\nvar extend = _util.extend;\r\nvar mixin = _util.mixin;\r\n\r\nvar modelUtil = require(\"../util/model\");\r\n\r\nvar Model = require(\"./Model\");\r\n\r\nvar ComponentModel = require(\"./Component\");\r\n\r\nvar globalDefault = require(\"./globalDefault\");\r\n\r\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\r\n\r\nvar _sourceHelper = require(\"../data/helper/sourceHelper\");\r\n\r\nvar resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n/**\r\n * ECharts global model\r\n *\r\n * @module {echarts/model/Global}\r\n */\r\n\r\n/**\r\n * Caution: If the mechanism should be changed some day, these cases\r\n * should be considered:\r\n *\r\n * (1) In `merge option` mode, if using the same option to call `setOption`\r\n * many times, the result should be the same (try our best to ensure that).\r\n * (2) In `merge option` mode, if a component has no id/name specified, it\r\n * will be merged by index, and the result sequence of the components is\r\n * consistent to the original sequence.\r\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\r\n * `mergeOption` in module:echarts/model/OptionManager.\r\n */\r\nvar OPTION_INNER_KEY = '\\0_ec_inner';\r\n/**\r\n * @alias module:echarts/model/Global\r\n *\r\n * @param {Object} option\r\n * @param {module:echarts/model/Model} parentModel\r\n * @param {Object} theme\r\n */\r\n\r\nvar GlobalModel = Model.extend({\r\n  init: function (option, parentModel, theme, optionManager) {\r\n    theme = theme || {};\r\n    this.option = null; // Mark as not initialized.\r\n\r\n    /**\r\n     * @type {module:echarts/model/Model}\r\n     * @private\r\n     */\r\n\r\n    this._theme = new Model(theme);\r\n    /**\r\n     * @type {module:echarts/model/OptionManager}\r\n     */\r\n\r\n    this._optionManager = optionManager;\r\n  },\r\n  setOption: function (option, optionPreprocessorFuncs) {\r\n    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\r\n\r\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\r\n\r\n    this.resetOption(null);\r\n  },\r\n\r\n  /**\r\n   * @param {string} type null/undefined: reset all.\r\n   *                      'recreate': force recreate all.\r\n   *                      'timeline': only reset timeline option\r\n   *                      'media': only reset media query option\r\n   * @return {boolean} Whether option changed.\r\n   */\r\n  resetOption: function (type) {\r\n    var optionChanged = false;\r\n    var optionManager = this._optionManager;\r\n\r\n    if (!type || type === 'recreate') {\r\n      var baseOption = optionManager.mountOption(type === 'recreate');\r\n\r\n      if (!this.option || type === 'recreate') {\r\n        initBase.call(this, baseOption);\r\n      } else {\r\n        this.restoreData();\r\n        this.mergeOption(baseOption);\r\n      }\r\n\r\n      optionChanged = true;\r\n    }\r\n\r\n    if (type === 'timeline' || type === 'media') {\r\n      this.restoreData();\r\n    }\r\n\r\n    if (!type || type === 'recreate' || type === 'timeline') {\r\n      var timelineOption = optionManager.getTimelineOption(this);\r\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\r\n    }\r\n\r\n    if (!type || type === 'recreate' || type === 'media') {\r\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\r\n\r\n      if (mediaOptions.length) {\r\n        each(mediaOptions, function (mediaOption) {\r\n          this.mergeOption(mediaOption, optionChanged = true);\r\n        }, this);\r\n      }\r\n    }\r\n\r\n    return optionChanged;\r\n  },\r\n\r\n  /**\r\n   * @protected\r\n   */\r\n  mergeOption: function (newOption) {\r\n    var option = this.option;\r\n    var componentsMap = this._componentsMap;\r\n    var newCptTypes = [];\r\n    resetSourceDefaulter(this); // If no component class, merge directly.\r\n    // For example: color, animaiton options, etc.\r\n\r\n    each(newOption, function (componentOption, mainType) {\r\n      if (componentOption == null) {\r\n        return;\r\n      }\r\n\r\n      if (!ComponentModel.hasClass(mainType)) {\r\n        // globalSettingTask.dirty();\r\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\r\n      } else if (mainType) {\r\n        newCptTypes.push(mainType);\r\n      }\r\n    });\r\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\r\n\r\n    function visitComponent(mainType, dependencies) {\r\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\r\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\r\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\r\n\r\n      each(mapResult, function (item, index) {\r\n        var opt = item.option;\r\n\r\n        if (isObject(opt)) {\r\n          item.keyInfo.mainType = mainType;\r\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\r\n        }\r\n      });\r\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\r\n      option[mainType] = [];\r\n      componentsMap.set(mainType, []);\r\n      each(mapResult, function (resultItem, index) {\r\n        var componentModel = resultItem.exist;\r\n        var newCptOption = resultItem.option;\r\n        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\r\n        // see removeEdgeAndAdd in topologicalTravel and\r\n        // ComponentModel.getAllClassMainTypes.\r\n\r\n        if (!newCptOption) {\r\n          componentModel.mergeOption({}, this);\r\n          componentModel.optionUpdated({}, false);\r\n        } else {\r\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\r\n\r\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\r\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\r\n\r\n            componentModel.mergeOption(newCptOption, this);\r\n            componentModel.optionUpdated(newCptOption, false);\r\n          } else {\r\n            // PENDING Global as parent ?\r\n            var extraOpt = extend({\r\n              dependentModels: dependentModels,\r\n              componentIndex: index\r\n            }, resultItem.keyInfo);\r\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\r\n            extend(componentModel, extraOpt);\r\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\r\n            // newCptOption has been used as componentModel.option\r\n            // and may be merged with theme and default, so pass null\r\n            // to avoid confusion.\r\n\r\n            componentModel.optionUpdated(null, true);\r\n          }\r\n        }\r\n\r\n        componentsMap.get(mainType)[index] = componentModel;\r\n        option[mainType][index] = componentModel.option;\r\n      }, this); // Backup series for filtering.\r\n\r\n      if (mainType === 'series') {\r\n        createSeriesIndices(this, componentsMap.get('series'));\r\n      }\r\n    }\r\n\r\n    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);\r\n  },\r\n\r\n  /**\r\n   * Get option for output (cloned option and inner info removed)\r\n   * @public\r\n   * @return {Object}\r\n   */\r\n  getOption: function () {\r\n    var option = clone(this.option);\r\n    each(option, function (opts, mainType) {\r\n      if (ComponentModel.hasClass(mainType)) {\r\n        var opts = modelUtil.normalizeToArray(opts);\r\n\r\n        for (var i = opts.length - 1; i >= 0; i--) {\r\n          // Remove options with inner id.\r\n          if (modelUtil.isIdInner(opts[i])) {\r\n            opts.splice(i, 1);\r\n          }\r\n        }\r\n\r\n        option[mainType] = opts;\r\n      }\r\n    });\r\n    delete option[OPTION_INNER_KEY];\r\n    return option;\r\n  },\r\n\r\n  /**\r\n   * @return {module:echarts/model/Model}\r\n   */\r\n  getTheme: function () {\r\n    return this._theme;\r\n  },\r\n\r\n  /**\r\n   * @param {string} mainType\r\n   * @param {number} [idx=0]\r\n   * @return {module:echarts/model/Component}\r\n   */\r\n  getComponent: function (mainType, idx) {\r\n    var list = this._componentsMap.get(mainType);\r\n\r\n    if (list) {\r\n      return list[idx || 0];\r\n    }\r\n  },\r\n\r\n  /**\r\n   * If none of index and id and name used, return all components with mainType.\r\n   * @param {Object} condition\r\n   * @param {string} condition.mainType\r\n   * @param {string} [condition.subType] If ignore, only query by mainType\r\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\r\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\r\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\r\n   * @return {Array.<module:echarts/model/Component>}\r\n   */\r\n  queryComponents: function (condition) {\r\n    var mainType = condition.mainType;\r\n\r\n    if (!mainType) {\r\n      return [];\r\n    }\r\n\r\n    var index = condition.index;\r\n    var id = condition.id;\r\n    var name = condition.name;\r\n\r\n    var cpts = this._componentsMap.get(mainType);\r\n\r\n    if (!cpts || !cpts.length) {\r\n      return [];\r\n    }\r\n\r\n    var result;\r\n\r\n    if (index != null) {\r\n      if (!isArray(index)) {\r\n        index = [index];\r\n      }\r\n\r\n      result = filter(map(index, function (idx) {\r\n        return cpts[idx];\r\n      }), function (val) {\r\n        return !!val;\r\n      });\r\n    } else if (id != null) {\r\n      var isIdArray = isArray(id);\r\n      result = filter(cpts, function (cpt) {\r\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\r\n      });\r\n    } else if (name != null) {\r\n      var isNameArray = isArray(name);\r\n      result = filter(cpts, function (cpt) {\r\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\r\n      });\r\n    } else {\r\n      // Return all components with mainType\r\n      result = cpts.slice();\r\n    }\r\n\r\n    return filterBySubType(result, condition);\r\n  },\r\n\r\n  /**\r\n   * The interface is different from queryComponents,\r\n   * which is convenient for inner usage.\r\n   *\r\n   * @usage\r\n   * var result = findComponents(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\r\n   * );\r\n   * var result = findComponents(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\r\n   * );\r\n   * var result = findComponents(\r\n   *     {mainType: 'series',\r\n   *     filter: function (model, index) {...}}\r\n   * );\r\n   * // result like [component0, componnet1, ...]\r\n   *\r\n   * @param {Object} condition\r\n   * @param {string} condition.mainType Mandatory.\r\n   * @param {string} [condition.subType] Optional.\r\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\r\n   *        where xxx is mainType.\r\n   *        If query attribute is null/undefined or has no index/id/name,\r\n   *        do not filtering by query conditions, which is convenient for\r\n   *        no-payload situations or when target of action is global.\r\n   * @param {Function} [condition.filter] parameter: component, return boolean.\r\n   * @return {Array.<module:echarts/model/Component>}\r\n   */\r\n  findComponents: function (condition) {\r\n    var query = condition.query;\r\n    var mainType = condition.mainType;\r\n    var queryCond = getQueryCond(query);\r\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\r\n    return doFilter(filterBySubType(result, condition));\r\n\r\n    function getQueryCond(q) {\r\n      var indexAttr = mainType + 'Index';\r\n      var idAttr = mainType + 'Id';\r\n      var nameAttr = mainType + 'Name';\r\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\r\n        mainType: mainType,\r\n        // subType will be filtered finally.\r\n        index: q[indexAttr],\r\n        id: q[idAttr],\r\n        name: q[nameAttr]\r\n      } : null;\r\n    }\r\n\r\n    function doFilter(res) {\r\n      return condition.filter ? filter(res, condition.filter) : res;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @usage\r\n   * eachComponent('legend', function (legendModel, index) {\r\n   *     ...\r\n   * });\r\n   * eachComponent(function (componentType, model, index) {\r\n   *     // componentType does not include subType\r\n   *     // (componentType is 'xxx' but not 'xxx.aa')\r\n   * });\r\n   * eachComponent(\r\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\r\n   *     function (model, index) {...}\r\n   * );\r\n   * eachComponent(\r\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\r\n   *     function (model, index) {...}\r\n   * );\r\n   *\r\n   * @param {string|Object=} mainType When mainType is object, the definition\r\n   *                                  is the same as the method 'findComponents'.\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n  eachComponent: function (mainType, cb, context) {\r\n    var componentsMap = this._componentsMap;\r\n\r\n    if (typeof mainType === 'function') {\r\n      context = cb;\r\n      cb = mainType;\r\n      componentsMap.each(function (components, componentType) {\r\n        each(components, function (component, index) {\r\n          cb.call(context, componentType, component, index);\r\n        });\r\n      });\r\n    } else if (isString(mainType)) {\r\n      each(componentsMap.get(mainType), cb, context);\r\n    } else if (isObject(mainType)) {\r\n      var queryResult = this.findComponents(mainType);\r\n      each(queryResult, cb, context);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @param {string} name\r\n   * @return {Array.<module:echarts/model/Series>}\r\n   */\r\n  getSeriesByName: function (name) {\r\n    var series = this._componentsMap.get('series');\r\n\r\n    return filter(series, function (oneSeries) {\r\n      return oneSeries.name === name;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @param {number} seriesIndex\r\n   * @return {module:echarts/model/Series}\r\n   */\r\n  getSeriesByIndex: function (seriesIndex) {\r\n    return this._componentsMap.get('series')[seriesIndex];\r\n  },\r\n\r\n  /**\r\n   * Get series list before filtered by type.\r\n   * FIXME: rename to getRawSeriesByType?\r\n   *\r\n   * @param {string} subType\r\n   * @return {Array.<module:echarts/model/Series>}\r\n   */\r\n  getSeriesByType: function (subType) {\r\n    var series = this._componentsMap.get('series');\r\n\r\n    return filter(series, function (oneSeries) {\r\n      return oneSeries.subType === subType;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @return {Array.<module:echarts/model/Series>}\r\n   */\r\n  getSeries: function () {\r\n    return this._componentsMap.get('series').slice();\r\n  },\r\n\r\n  /**\r\n   * @return {number}\r\n   */\r\n  getSeriesCount: function () {\r\n    return this._componentsMap.get('series').length;\r\n  },\r\n\r\n  /**\r\n   * After filtering, series may be different\r\n   * frome raw series.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n  eachSeries: function (cb, context) {\r\n    assertSeriesInitialized(this);\r\n    each(this._seriesIndices, function (rawSeriesIndex) {\r\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\r\n\r\n      cb.call(context, series, rawSeriesIndex);\r\n    }, this);\r\n  },\r\n\r\n  /**\r\n   * Iterate raw series before filtered.\r\n   *\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n  eachRawSeries: function (cb, context) {\r\n    each(this._componentsMap.get('series'), cb, context);\r\n  },\r\n\r\n  /**\r\n   * After filtering, series may be different.\r\n   * frome raw series.\r\n   *\r\n   * @param {string} subType.\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n  eachSeriesByType: function (subType, cb, context) {\r\n    assertSeriesInitialized(this);\r\n    each(this._seriesIndices, function (rawSeriesIndex) {\r\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\r\n\r\n      if (series.subType === subType) {\r\n        cb.call(context, series, rawSeriesIndex);\r\n      }\r\n    }, this);\r\n  },\r\n\r\n  /**\r\n   * Iterate raw series before filtered of given type.\r\n   *\r\n   * @parma {string} subType\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n  eachRawSeriesByType: function (subType, cb, context) {\r\n    return each(this.getSeriesByType(subType), cb, context);\r\n  },\r\n\r\n  /**\r\n   * @param {module:echarts/model/Series} seriesModel\r\n   */\r\n  isSeriesFiltered: function (seriesModel) {\r\n    assertSeriesInitialized(this);\r\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\r\n  },\r\n\r\n  /**\r\n   * @return {Array.<number>}\r\n   */\r\n  getCurrentSeriesIndices: function () {\r\n    return (this._seriesIndices || []).slice();\r\n  },\r\n\r\n  /**\r\n   * @param {Function} cb\r\n   * @param {*} context\r\n   */\r\n  filterSeries: function (cb, context) {\r\n    assertSeriesInitialized(this);\r\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\r\n    createSeriesIndices(this, filteredSeries);\r\n  },\r\n  restoreData: function (payload) {\r\n    var componentsMap = this._componentsMap;\r\n    createSeriesIndices(this, componentsMap.get('series'));\r\n    var componentTypes = [];\r\n    componentsMap.each(function (components, componentType) {\r\n      componentTypes.push(componentType);\r\n    });\r\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\r\n      each(componentsMap.get(componentType), function (component) {\r\n        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();\r\n      });\r\n    });\r\n  }\r\n});\r\n\r\nfunction isNotTargetSeries(seriesModel, payload) {\r\n  if (payload) {\r\n    var index = payload.seiresIndex;\r\n    var id = payload.seriesId;\r\n    var name = payload.seriesName;\r\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;\r\n  }\r\n}\r\n/**\r\n * @inner\r\n */\r\n\r\n\r\nfunction mergeTheme(option, theme) {\r\n  // PENDING\r\n  // NOT use `colorLayer` in theme if option has `color`\r\n  var notMergeColorLayer = option.color && !option.colorLayer;\r\n  each(theme, function (themeItem, name) {\r\n    if (name === 'colorLayer' && notMergeColorLayer) {\r\n      return;\r\n    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\r\n\r\n\r\n    if (!ComponentModel.hasClass(name)) {\r\n      if (typeof themeItem === 'object') {\r\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\r\n      } else {\r\n        if (option[name] == null) {\r\n          option[name] = themeItem;\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction initBase(baseOption) {\r\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\r\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\r\n\r\n  this.option = {};\r\n  this.option[OPTION_INNER_KEY] = 1;\r\n  /**\r\n   * Init with series: [], in case of calling findSeries method\r\n   * before series initialized.\r\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\r\n   * @private\r\n   */\r\n\r\n  this._componentsMap = createHashMap({\r\n    series: []\r\n  });\r\n  /**\r\n   * Mapping between filtered series list and raw series list.\r\n   * key: filtered series indices, value: raw series indices.\r\n   * @type {Array.<nubmer>}\r\n   * @private\r\n   */\r\n\r\n  this._seriesIndices;\r\n  this._seriesIndicesMap;\r\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\r\n\r\n  merge(baseOption, globalDefault, false);\r\n  this.mergeOption(baseOption);\r\n}\r\n/**\r\n * @inner\r\n * @param {Array.<string>|string} types model types\r\n * @return {Object} key: {string} type, value: {Array.<Object>} models\r\n */\r\n\r\n\r\nfunction getComponentsByTypes(componentsMap, types) {\r\n  if (!isArray(types)) {\r\n    types = types ? [types] : [];\r\n  }\r\n\r\n  var ret = {};\r\n  each(types, function (type) {\r\n    ret[type] = (componentsMap.get(type) || []).slice();\r\n  });\r\n  return ret;\r\n}\r\n/**\r\n * @inner\r\n */\r\n\r\n\r\nfunction determineSubType(mainType, newCptOption, existComponent) {\r\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\r\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\r\n\r\n  return subType;\r\n}\r\n/**\r\n * @inner\r\n */\r\n\r\n\r\nfunction createSeriesIndices(ecModel, seriesModels) {\r\n  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {\r\n    return series.componentIndex;\r\n  }) || []);\r\n}\r\n/**\r\n * @inner\r\n */\r\n\r\n\r\nfunction filterBySubType(components, condition) {\r\n  // Using hasOwnProperty for restrict. Consider\r\n  // subType is undefined in user payload.\r\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\r\n    return cpt.subType === condition.subType;\r\n  }) : components;\r\n}\r\n/**\r\n * @inner\r\n */\r\n\r\n\r\nfunction assertSeriesInitialized(ecModel) {}\r\n\r\nmixin(GlobalModel, colorPaletteMixin);\r\nvar _default = GlobalModel;\r\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}