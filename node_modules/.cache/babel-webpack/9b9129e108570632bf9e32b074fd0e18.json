{"ast":null,"code":"var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\nvar getNativeEvent = _event.getNativeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n/* global document */\n\n\nvar TOUCH_CLICK_DELAY = 300;\nvar globalEventSupported = env.domSupported;\n\nvar localNativeListenerNames = function () {\n  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n  var pointerEventNameMap = {\n    pointerdown: 1,\n    pointerup: 1,\n    pointermove: 1,\n    pointerout: 1\n  };\n  var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n    var nm = name.replace('mouse', 'pointer');\n    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\n  });\n  return {\n    mouse: mouseHandlerNames,\n    touch: touchHandlerNames,\n    pointer: pointerHandlerNames\n  };\n}();\n\nvar globalNativeListenerNames = {\n  mouse: ['mousemove', 'mouseup'],\n  pointer: ['pointermove', 'pointerup']\n};\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\r\n * Prevent mouse event from being dispatched after Touch Events action\r\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\r\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\r\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\r\n * Result: Blocking Mouse Events for 700ms.\r\n *\r\n * @param {DOMHandlerScope} scope\r\n */\n\n\nfunction setTouchTimer(scope) {\n  scope.touching = true;\n\n  if (scope.touchTimer != null) {\n    clearTimeout(scope.touchTimer);\n    scope.touchTimer = null;\n  }\n\n  scope.touchTimer = setTimeout(function () {\n    scope.touching = false;\n    scope.touchTimer = null;\n  }, 700);\n} // Mark touch, which is useful in distinguish touch and\n// mouse event in upper applicatoin.\n\n\nfunction markTouch(event) {\n  event && (event.zrByTouch = true);\n} // function markTriggeredFromLocal(event) {\n//     event && (event.__zrIsFromLocal = true);\n// }\n// function isTriggeredFromLocal(instance, event) {\n//     return !!(event && event.__zrIsFromLocal);\n// }\n\n\nfunction normalizeGlobalEvent(instance, event) {\n  // offsetX, offsetY still need to be calculated. They are necessary in the event\n  // handlers of the upper applications. Set `true` to force calculate them.\n  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);\n}\n/**\r\n * Detect whether the given el is in `painterRoot`.\r\n */\n\n\nfunction isLocalEl(instance, el) {\n  var isLocal = false;\n\n  do {\n    el = el && el.parentNode;\n  } while (el && el.nodeType !== 9 && !(isLocal = el === instance.painterRoot));\n\n  return isLocal;\n}\n/**\r\n * Make a fake event but not change the original event,\r\n * becuase the global event probably be used by other\r\n * listeners not belonging to zrender.\r\n * @class\r\n */\n\n\nfunction FakeGlobalEvent(instance, event) {\n  this.type = event.type;\n  this.target = this.currentTarget = instance.dom;\n  this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY\n\n  this.clientX = event.clientX;\n  this.clientY = event.clientY; // Because we do not mount global listeners to touch events,\n  // we do not copy `targetTouches` and `changedTouches` here.\n}\n\nvar fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,\n// otherwise it is dangerous. See more details in\n// [Drag outside] in `Handler.js`.\n\nfakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;\n/**\r\n * Local DOM Handlers\r\n * @this {HandlerProxy}\r\n */\n\nvar localDOMHandlers = {\n  mousedown: function mousedown(event) {\n    event = normalizeEvent(this.dom, event);\n    this._mayPointerCapture = [event.zrX, event.zrY];\n    this.trigger('mousedown', event);\n  },\n  mousemove: function mousemove(event) {\n    event = normalizeEvent(this.dom, event);\n    var downPoint = this._mayPointerCapture;\n\n    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {\n      togglePointerCapture(this, true);\n    }\n\n    this.trigger('mousemove', event);\n  },\n  mouseup: function mouseup(event) {\n    event = normalizeEvent(this.dom, event);\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n  },\n  mouseout: function mouseout(event) {\n    event = normalizeEvent(this.dom, event); // Similarly to the browser did on `document` and touch event,\n    // `globalout` will be delayed to final pointer cature release.\n\n    if (this._pointerCapturing) {\n      event.zrEventControl = 'no_globalout';\n    } // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n\n    var element = event.toElement || event.relatedTarget;\n    event.zrIsToLocalDOM = isLocalEl(this, element);\n    this.trigger('mouseout', event);\n  },\n  touchstart: function touchstart(event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this._lastTouchMoment = new Date();\n    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,\n    // we simulate \"mouseover-->mousedown\" in touch device. So we trigger\n    // `mousemove` here (to trigger `mouseover` inside), and then trigger\n    // `mousedown`.\n\n    localDOMHandlers.mousemove.call(this, event);\n    localDOMHandlers.mousedown.call(this, event);\n  },\n  touchmove: function touchmove(event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    localDOMHandlers.mousemove.call(this, event);\n  },\n  touchend: function touchend(event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'end');\n    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      localDOMHandlers.click.call(this, event);\n    }\n  },\n  pointerdown: function pointerdown(event) {\n    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function pointermove(event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function pointerup(event) {\n    localDOMHandlers.mouseup.call(this, event);\n  },\n  pointerout: function pointerout(event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check localDOMHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mouseout.call(this, event);\n    }\n  }\n};\n/**\r\n * Othere DOM UI Event handlers for zr dom.\r\n * @this {HandlerProxy}\r\n */\n\nzrUtil.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  localDOMHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\r\n * DOM UI Event handlers for global page.\r\n *\r\n * [Caution]:\r\n * those handlers should both support in capture phase and bubble phase!\r\n *\r\n * @this {HandlerProxy}\r\n */\n\nvar globalDOMHandlers = {\n  pointermove: function pointermove(event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      globalDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function pointerup(event) {\n    globalDOMHandlers.mouseup.call(this, event);\n  },\n  mousemove: function mousemove(event) {\n    this.trigger('mousemove', event);\n  },\n  mouseup: function mouseup(event) {\n    var pointerCaptureReleasing = this._pointerCapturing;\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n\n    if (pointerCaptureReleasing) {\n      event.zrEventControl = 'only_globalout';\n      this.trigger('mouseout', event);\n    }\n  }\n};\n/**\r\n * @param {HandlerProxy} instance\r\n * @param {DOMHandlerScope} scope\r\n */\n\nfunction mountLocalDOMEventListeners(instance, scope) {\n  var domHandlers = scope.domHandlers;\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        // markTriggeredFromLocal(event);\n        domHandlers[nativeEventName].call(instance, event);\n      });\n    }); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {\n        mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n          setTouchTimer(scope);\n        });\n      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        event = getNativeEvent(event);\n\n        if (!scope.touching) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    });\n  }\n}\n/**\r\n * @param {HandlerProxy} instance\r\n * @param {DOMHandlerScope} scope\r\n */\n\n\nfunction mountGlobalDOMEventListeners(instance, scope) {\n  // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.\n  if (env.pointerEventsSupported) {\n    zrUtil.each(globalNativeListenerNames.pointer, mount);\n  } // Touch event has implemented \"drag outside\" so we do not mount global listener for touch event.\n  // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)\n  // We do not consider \"both-support-touch-and-mouse device\" for this feature (see the comment of\n  // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.\n  else if (!env.touchEventsSupported) {\n      zrUtil.each(globalNativeListenerNames.mouse, mount);\n    }\n\n  function mount(nativeEventName) {\n    function nativeEventListener(event) {\n      event = getNativeEvent(event); // See the reason in [Drag outside] in `Handler.js`\n      // This checking supports both `useCapture` or not.\n      // PENDING: if there is performance issue in some devices,\n      // we probably can not use `useCapture` and change a easier\n      // to judes whether local (mark).\n\n      if (!isLocalEl(instance, event.target)) {\n        event = normalizeGlobalEvent(instance, event);\n        scope.domHandlers[nativeEventName].call(instance, event);\n      }\n    }\n\n    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {\n      capture: true\n    } // See [Drag Outside] in `Handler.js`\n    );\n  }\n}\n\nfunction mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {\n  scope.mounted[nativeEventName] = listener;\n  scope.listenerOpts[nativeEventName] = opt;\n  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);\n}\n\nfunction unmountDOMEventListeners(scope) {\n  var mounted = scope.mounted;\n\n  for (var nativeEventName in mounted) {\n    if (mounted.hasOwnProperty(nativeEventName)) {\n      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);\n    }\n  }\n\n  scope.mounted = {};\n}\n/**\r\n * See [Drag Outside] in `Handler.js`.\r\n * @implement\r\n * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.\r\n *        `true`: start to capture pointer if it is not capturing.\r\n *        `false`: end the capture if it is capturing.\r\n */\n\n\nfunction togglePointerCapture(instance, isPointerCapturing) {\n  instance._mayPointerCapture = null;\n\n  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {\n    instance._pointerCapturing = isPointerCapturing;\n    var globalHandlerScope = instance._globalHandlerScope;\n    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);\n  }\n}\n/**\r\n * @inner\r\n * @class\r\n */\n\n\nfunction DOMHandlerScope(domTarget, domHandlers) {\n  this.domTarget = domTarget;\n  this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.\n  // Used for unmount.\n\n  this.mounted = {};\n  this.listenerOpts = {};\n  this.touchTimer = null;\n  this.touching = false;\n}\n/**\r\n * @public\r\n * @class\r\n */\n\n\nfunction HandlerDomProxy(dom, painterRoot) {\n  Eventful.call(this);\n  this.dom = dom;\n  this.painterRoot = painterRoot;\n  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\n\n  if (globalEventSupported) {\n    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);\n  }\n  /**\r\n   * @type {boolean}\r\n   */\n\n\n  this._pointerCapturing = false;\n  /**\r\n   * @type {Array.<number>} [x, y] or null.\r\n   */\n\n  this._mayPointerCapture = null;\n  mountLocalDOMEventListeners(this, this._localHandlerScope);\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  unmountDOMEventListeners(this._localHandlerScope);\n\n  if (globalEventSupported) {\n    unmountDOMEventListeners(this._globalHandlerScope);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/zrender/lib/dom/HandlerProxy.js"],"names":["_event","require","addEventListener","removeEventListener","normalizeEvent","getNativeEvent","zrUtil","Eventful","env","TOUCH_CLICK_DELAY","globalEventSupported","domSupported","localNativeListenerNames","mouseHandlerNames","touchHandlerNames","pointerEventNameMap","pointerdown","pointerup","pointermove","pointerout","pointerHandlerNames","map","name","nm","replace","hasOwnProperty","mouse","touch","pointer","globalNativeListenerNames","eventNameFix","browser","firefox","isPointerFromTouch","event","pointerType","setTouchTimer","scope","touching","touchTimer","clearTimeout","setTimeout","markTouch","zrByTouch","normalizeGlobalEvent","instance","dom","FakeGlobalEvent","isLocalEl","el","isLocal","parentNode","nodeType","painterRoot","type","target","currentTarget","clientX","clientY","fakeGlobalEventProto","prototype","stopPropagation","stopImmediatePropagation","preventDefault","noop","localDOMHandlers","mousedown","_mayPointerCapture","zrX","zrY","trigger","mousemove","downPoint","togglePointerCapture","mouseup","mouseout","_pointerCapturing","zrEventControl","element","toElement","relatedTarget","zrIsToLocalDOM","touchstart","_lastTouchMoment","Date","handler","processGesture","call","touchmove","touchend","click","each","globalDOMHandlers","pointerCaptureReleasing","mountLocalDOMEventListeners","domHandlers","pointerEventsSupported","nativeEventName","mountSingleDOMEventListener","touchEventsSupported","mountGlobalDOMEventListeners","mount","nativeEventListener","capture","listener","opt","mounted","listenerOpts","domTarget","unmountDOMEventListeners","isPointerCapturing","globalHandlerScope","_globalHandlerScope","DOMHandlerScope","HandlerDomProxy","_localHandlerScope","document","handlerDomProxyProto","dispose","setCursor","cursorStyle","style","cursor","mixin","_default","module","exports"],"mappings":"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","sourcesContent":["var _event = require(\"../core/event\");\r\n\r\nvar addEventListener = _event.addEventListener;\r\nvar removeEventListener = _event.removeEventListener;\r\nvar normalizeEvent = _event.normalizeEvent;\r\nvar getNativeEvent = _event.getNativeEvent;\r\n\r\nvar zrUtil = require(\"../core/util\");\r\n\r\nvar Eventful = require(\"../mixin/Eventful\");\r\n\r\nvar env = require(\"../core/env\");\r\n\r\n/* global document */\r\nvar TOUCH_CLICK_DELAY = 300;\r\nvar globalEventSupported = env.domSupported;\r\n\r\nvar localNativeListenerNames = function () {\r\n  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\r\n  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\r\n  var pointerEventNameMap = {\r\n    pointerdown: 1,\r\n    pointerup: 1,\r\n    pointermove: 1,\r\n    pointerout: 1\r\n  };\r\n  var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\r\n    var nm = name.replace('mouse', 'pointer');\r\n    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\r\n  });\r\n  return {\r\n    mouse: mouseHandlerNames,\r\n    touch: touchHandlerNames,\r\n    pointer: pointerHandlerNames\r\n  };\r\n}();\r\n\r\nvar globalNativeListenerNames = {\r\n  mouse: ['mousemove', 'mouseup'],\r\n  pointer: ['pointermove', 'pointerup']\r\n};\r\n\r\nfunction eventNameFix(name) {\r\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\r\n}\r\n\r\nfunction isPointerFromTouch(event) {\r\n  var pointerType = event.pointerType;\r\n  return pointerType === 'pen' || pointerType === 'touch';\r\n} // function useMSGuesture(handlerProxy, event) {\r\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\r\n// }\r\n// function onMSGestureChange(proxy, event) {\r\n//     if (event.translationX || event.translationY) {\r\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\r\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\r\n//     }\r\n//     if (event.scale !== 1) {\r\n//         event.pinchX = event.offsetX;\r\n//         event.pinchY = event.offsetY;\r\n//         event.pinchScale = event.scale;\r\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\r\n//     }\r\n// }\r\n\r\n/**\r\n * Prevent mouse event from being dispatched after Touch Events action\r\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\r\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\r\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\r\n * Result: Blocking Mouse Events for 700ms.\r\n *\r\n * @param {DOMHandlerScope} scope\r\n */\r\n\r\n\r\nfunction setTouchTimer(scope) {\r\n  scope.touching = true;\r\n\r\n  if (scope.touchTimer != null) {\r\n    clearTimeout(scope.touchTimer);\r\n    scope.touchTimer = null;\r\n  }\r\n\r\n  scope.touchTimer = setTimeout(function () {\r\n    scope.touching = false;\r\n    scope.touchTimer = null;\r\n  }, 700);\r\n} // Mark touch, which is useful in distinguish touch and\r\n// mouse event in upper applicatoin.\r\n\r\n\r\nfunction markTouch(event) {\r\n  event && (event.zrByTouch = true);\r\n} // function markTriggeredFromLocal(event) {\r\n//     event && (event.__zrIsFromLocal = true);\r\n// }\r\n// function isTriggeredFromLocal(instance, event) {\r\n//     return !!(event && event.__zrIsFromLocal);\r\n// }\r\n\r\n\r\nfunction normalizeGlobalEvent(instance, event) {\r\n  // offsetX, offsetY still need to be calculated. They are necessary in the event\r\n  // handlers of the upper applications. Set `true` to force calculate them.\r\n  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);\r\n}\r\n/**\r\n * Detect whether the given el is in `painterRoot`.\r\n */\r\n\r\n\r\nfunction isLocalEl(instance, el) {\r\n  var isLocal = false;\r\n\r\n  do {\r\n    el = el && el.parentNode;\r\n  } while (el && el.nodeType !== 9 && !(isLocal = el === instance.painterRoot));\r\n\r\n  return isLocal;\r\n}\r\n/**\r\n * Make a fake event but not change the original event,\r\n * becuase the global event probably be used by other\r\n * listeners not belonging to zrender.\r\n * @class\r\n */\r\n\r\n\r\nfunction FakeGlobalEvent(instance, event) {\r\n  this.type = event.type;\r\n  this.target = this.currentTarget = instance.dom;\r\n  this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY\r\n\r\n  this.clientX = event.clientX;\r\n  this.clientY = event.clientY; // Because we do not mount global listeners to touch events,\r\n  // we do not copy `targetTouches` and `changedTouches` here.\r\n}\r\n\r\nvar fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,\r\n// otherwise it is dangerous. See more details in\r\n// [Drag outside] in `Handler.js`.\r\n\r\nfakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;\r\n/**\r\n * Local DOM Handlers\r\n * @this {HandlerProxy}\r\n */\r\n\r\nvar localDOMHandlers = {\r\n  mousedown: function (event) {\r\n    event = normalizeEvent(this.dom, event);\r\n    this._mayPointerCapture = [event.zrX, event.zrY];\r\n    this.trigger('mousedown', event);\r\n  },\r\n  mousemove: function (event) {\r\n    event = normalizeEvent(this.dom, event);\r\n    var downPoint = this._mayPointerCapture;\r\n\r\n    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {\r\n      togglePointerCapture(this, true);\r\n    }\r\n\r\n    this.trigger('mousemove', event);\r\n  },\r\n  mouseup: function (event) {\r\n    event = normalizeEvent(this.dom, event);\r\n    togglePointerCapture(this, false);\r\n    this.trigger('mouseup', event);\r\n  },\r\n  mouseout: function (event) {\r\n    event = normalizeEvent(this.dom, event); // Similarly to the browser did on `document` and touch event,\r\n    // `globalout` will be delayed to final pointer cature release.\r\n\r\n    if (this._pointerCapturing) {\r\n      event.zrEventControl = 'no_globalout';\r\n    } // There might be some doms created by upper layer application\r\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\r\n    // dom created by echarts), where 'globalout' event should not\r\n    // be triggered when mouse enters these doms. (But 'mouseout'\r\n    // should be triggered at the original hovered element as usual).\r\n\r\n\r\n    var element = event.toElement || event.relatedTarget;\r\n    event.zrIsToLocalDOM = isLocalEl(this, element);\r\n    this.trigger('mouseout', event);\r\n  },\r\n  touchstart: function (event) {\r\n    // Default mouse behaviour should not be disabled here.\r\n    // For example, page may needs to be slided.\r\n    event = normalizeEvent(this.dom, event);\r\n    markTouch(event);\r\n    this._lastTouchMoment = new Date();\r\n    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,\r\n    // we simulate \"mouseover-->mousedown\" in touch device. So we trigger\r\n    // `mousemove` here (to trigger `mouseover` inside), and then trigger\r\n    // `mousedown`.\r\n\r\n    localDOMHandlers.mousemove.call(this, event);\r\n    localDOMHandlers.mousedown.call(this, event);\r\n  },\r\n  touchmove: function (event) {\r\n    event = normalizeEvent(this.dom, event);\r\n    markTouch(event);\r\n    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether\r\n    // there is gestrue event, because mouse move and pinch may\r\n    // be used at the same time.\r\n\r\n    localDOMHandlers.mousemove.call(this, event);\r\n  },\r\n  touchend: function (event) {\r\n    event = normalizeEvent(this.dom, event);\r\n    markTouch(event);\r\n    this.handler.processGesture(event, 'end');\r\n    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\r\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\r\n    // we can conveniently implement \"hover style\" in both PC and touch device just\r\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\r\n    // to remove \"hover style\" on an element, without any additional code for\r\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\r\n    // style\" will remain for user view)\r\n    // click event should always be triggered no matter whether\r\n    // there is gestrue event. System click can not be prevented.\r\n\r\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\r\n      localDOMHandlers.click.call(this, event);\r\n    }\r\n  },\r\n  pointerdown: function (event) {\r\n    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\r\n    //     this._msGesture.addPointer(event.pointerId);\r\n    // }\r\n  },\r\n  pointermove: function (event) {\r\n    // FIXME\r\n    // pointermove is so sensitive that it always triggered when\r\n    // tap(click) on touch screen, which affect some judgement in\r\n    // upper application. So, we dont support mousemove on MS touch\r\n    // device yet.\r\n    if (!isPointerFromTouch(event)) {\r\n      localDOMHandlers.mousemove.call(this, event);\r\n    }\r\n  },\r\n  pointerup: function (event) {\r\n    localDOMHandlers.mouseup.call(this, event);\r\n  },\r\n  pointerout: function (event) {\r\n    // pointerout will be triggered when tap on touch screen\r\n    // (IE11+/Edge on MS Surface) after click event triggered,\r\n    // which is inconsistent with the mousout behavior we defined\r\n    // in touchend. So we unify them.\r\n    // (check localDOMHandlers.touchend for detailed explanation)\r\n    if (!isPointerFromTouch(event)) {\r\n      localDOMHandlers.mouseout.call(this, event);\r\n    }\r\n  }\r\n};\r\n/**\r\n * Othere DOM UI Event handlers for zr dom.\r\n * @this {HandlerProxy}\r\n */\r\n\r\nzrUtil.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\r\n  localDOMHandlers[name] = function (event) {\r\n    event = normalizeEvent(this.dom, event);\r\n    this.trigger(name, event);\r\n  };\r\n});\r\n/**\r\n * DOM UI Event handlers for global page.\r\n *\r\n * [Caution]:\r\n * those handlers should both support in capture phase and bubble phase!\r\n *\r\n * @this {HandlerProxy}\r\n */\r\n\r\nvar globalDOMHandlers = {\r\n  pointermove: function (event) {\r\n    // FIXME\r\n    // pointermove is so sensitive that it always triggered when\r\n    // tap(click) on touch screen, which affect some judgement in\r\n    // upper application. So, we dont support mousemove on MS touch\r\n    // device yet.\r\n    if (!isPointerFromTouch(event)) {\r\n      globalDOMHandlers.mousemove.call(this, event);\r\n    }\r\n  },\r\n  pointerup: function (event) {\r\n    globalDOMHandlers.mouseup.call(this, event);\r\n  },\r\n  mousemove: function (event) {\r\n    this.trigger('mousemove', event);\r\n  },\r\n  mouseup: function (event) {\r\n    var pointerCaptureReleasing = this._pointerCapturing;\r\n    togglePointerCapture(this, false);\r\n    this.trigger('mouseup', event);\r\n\r\n    if (pointerCaptureReleasing) {\r\n      event.zrEventControl = 'only_globalout';\r\n      this.trigger('mouseout', event);\r\n    }\r\n  }\r\n};\r\n/**\r\n * @param {HandlerProxy} instance\r\n * @param {DOMHandlerScope} scope\r\n */\r\n\r\nfunction mountLocalDOMEventListeners(instance, scope) {\r\n  var domHandlers = scope.domHandlers;\r\n\r\n  if (env.pointerEventsSupported) {\r\n    // Only IE11+/Edge\r\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\r\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\r\n    // at the same time.\r\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\r\n    // screen, which do not occurs in pointer event.\r\n    // So we use pointer event to both detect touch gesture and mouse behavior.\r\n    zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {\r\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\r\n        // markTriggeredFromLocal(event);\r\n        domHandlers[nativeEventName].call(instance, event);\r\n      });\r\n    }); // FIXME\r\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\r\n    // which does not prevent defuault behavior occasionally (which may cause view port\r\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\r\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\r\n    // touch screen. And we only support click behavior on MS touch screen now.\r\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\r\n    // We dont support touch on IE on win7.\r\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\r\n    // if (typeof MSGesture === 'function') {\r\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\r\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\r\n    // }\r\n  } else {\r\n    if (env.touchEventsSupported) {\r\n      zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {\r\n        mountSingleDOMEventListener(scope, nativeEventName, function (event) {\r\n          // markTriggeredFromLocal(event);\r\n          domHandlers[nativeEventName].call(instance, event);\r\n          setTouchTimer(scope);\r\n        });\r\n      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\r\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\r\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\r\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\r\n    // mouse event can not be handle in those devices.\r\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\r\n    // mouseevent after touch event triggered, see `setTouchTimer`.\r\n\r\n\r\n    zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {\r\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\r\n        event = getNativeEvent(event);\r\n\r\n        if (!scope.touching) {\r\n          // markTriggeredFromLocal(event);\r\n          domHandlers[nativeEventName].call(instance, event);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n/**\r\n * @param {HandlerProxy} instance\r\n * @param {DOMHandlerScope} scope\r\n */\r\n\r\n\r\nfunction mountGlobalDOMEventListeners(instance, scope) {\r\n  // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.\r\n  if (env.pointerEventsSupported) {\r\n    zrUtil.each(globalNativeListenerNames.pointer, mount);\r\n  } // Touch event has implemented \"drag outside\" so we do not mount global listener for touch event.\r\n  // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)\r\n  // We do not consider \"both-support-touch-and-mouse device\" for this feature (see the comment of\r\n  // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.\r\n  else if (!env.touchEventsSupported) {\r\n      zrUtil.each(globalNativeListenerNames.mouse, mount);\r\n    }\r\n\r\n  function mount(nativeEventName) {\r\n    function nativeEventListener(event) {\r\n      event = getNativeEvent(event); // See the reason in [Drag outside] in `Handler.js`\r\n      // This checking supports both `useCapture` or not.\r\n      // PENDING: if there is performance issue in some devices,\r\n      // we probably can not use `useCapture` and change a easier\r\n      // to judes whether local (mark).\r\n\r\n      if (!isLocalEl(instance, event.target)) {\r\n        event = normalizeGlobalEvent(instance, event);\r\n        scope.domHandlers[nativeEventName].call(instance, event);\r\n      }\r\n    }\r\n\r\n    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {\r\n      capture: true\r\n    } // See [Drag Outside] in `Handler.js`\r\n    );\r\n  }\r\n}\r\n\r\nfunction mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {\r\n  scope.mounted[nativeEventName] = listener;\r\n  scope.listenerOpts[nativeEventName] = opt;\r\n  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);\r\n}\r\n\r\nfunction unmountDOMEventListeners(scope) {\r\n  var mounted = scope.mounted;\r\n\r\n  for (var nativeEventName in mounted) {\r\n    if (mounted.hasOwnProperty(nativeEventName)) {\r\n      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);\r\n    }\r\n  }\r\n\r\n  scope.mounted = {};\r\n}\r\n/**\r\n * See [Drag Outside] in `Handler.js`.\r\n * @implement\r\n * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.\r\n *        `true`: start to capture pointer if it is not capturing.\r\n *        `false`: end the capture if it is capturing.\r\n */\r\n\r\n\r\nfunction togglePointerCapture(instance, isPointerCapturing) {\r\n  instance._mayPointerCapture = null;\r\n\r\n  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {\r\n    instance._pointerCapturing = isPointerCapturing;\r\n    var globalHandlerScope = instance._globalHandlerScope;\r\n    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);\r\n  }\r\n}\r\n/**\r\n * @inner\r\n * @class\r\n */\r\n\r\n\r\nfunction DOMHandlerScope(domTarget, domHandlers) {\r\n  this.domTarget = domTarget;\r\n  this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.\r\n  // Used for unmount.\r\n\r\n  this.mounted = {};\r\n  this.listenerOpts = {};\r\n  this.touchTimer = null;\r\n  this.touching = false;\r\n}\r\n/**\r\n * @public\r\n * @class\r\n */\r\n\r\n\r\nfunction HandlerDomProxy(dom, painterRoot) {\r\n  Eventful.call(this);\r\n  this.dom = dom;\r\n  this.painterRoot = painterRoot;\r\n  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\r\n\r\n  if (globalEventSupported) {\r\n    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);\r\n  }\r\n  /**\r\n   * @type {boolean}\r\n   */\r\n\r\n\r\n  this._pointerCapturing = false;\r\n  /**\r\n   * @type {Array.<number>} [x, y] or null.\r\n   */\r\n\r\n  this._mayPointerCapture = null;\r\n  mountLocalDOMEventListeners(this, this._localHandlerScope);\r\n}\r\n\r\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\r\n\r\nhandlerDomProxyProto.dispose = function () {\r\n  unmountDOMEventListeners(this._localHandlerScope);\r\n\r\n  if (globalEventSupported) {\r\n    unmountDOMEventListeners(this._globalHandlerScope);\r\n  }\r\n};\r\n\r\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\r\n  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\r\n};\r\n\r\nzrUtil.mixin(HandlerDomProxy, Eventful);\r\nvar _default = HandlerDomProxy;\r\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}