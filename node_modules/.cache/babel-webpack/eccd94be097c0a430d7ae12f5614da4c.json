{"ast":null,"code":"/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar _number = require(\"../util/number\");\n\nvar linearMap = _number.linearMap;\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\r\n * @param {Object} option\r\n * @param {string} [option.type] See visualHandlers.\r\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\r\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\r\n *                                              required when mappingMethod is 'linear'\r\n * @param {Array.<Object>=} [option.pieceList] [\r\n *                                             {value: someValue},\r\n *                                             {interval: [min1, max1], visual: {...}},\r\n *                                             {interval: [min2, max2]}\r\n *                                             ],\r\n *                                            required when mappingMethod is 'piecewise'.\r\n *                                            Visual for only each piece can be specified.\r\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\r\n *                                            required when mappingMethod is 'category'.\r\n *                                            If no option.categories, categories is set\r\n *                                            as [0, 1, 2, ...].\r\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\r\n * @param {(Array|Object|*)} [option.visual]  Visual data.\r\n *                                            when mappingMethod is 'category',\r\n *                                            visual data can be array or object\r\n *                                            (like: {cate1: '#222', none: '#fff'})\r\n *                                            or primary types (which represents\r\n *                                            defualt category visual), otherwise visual\r\n *                                            can be array or primary (which will be\r\n *                                            normalized to array).\r\n *\r\n */\n\nvar VisualMapping = function VisualMapping(option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\r\n   * @readOnly\r\n   * @type {Object}\r\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\r\n   * @readOnly\r\n   * @type {string}\r\n   */\n\n  this.type = visualType;\n  /**\r\n   * @readOnly\r\n   * @type {string}\r\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\r\n   * @private\r\n   * @type {Function}\r\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\r\n   * @public\r\n   * @type {Function}\r\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\r\n   * @public\r\n   * @type {Function}\r\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\r\n   * @private\r\n   * @type {Function}\r\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\n\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function mapValueToVisual(value) {\n    var normalized = this._normalizeData(value);\n\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function getNormalizer() {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n\n    /**\r\n     * Create a mapper function\r\n     * @return {Function}\r\n     */\n    getColorMapper: function getColorMapper() {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function linear(normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function piecewise(normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  liftZ: {\n    applyVisual: makeApplyVisual('liftZ'),\n    _doMap: {\n      linear: doMapFixed,\n      category: doMapFixed,\n      piecewise: doMapFixed,\n      fixed: doMapFixed\n    }\n  },\n  symbol: {\n    applyVisual: function applyVisual(value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function piecewise(normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function applyVisual(value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function linear(normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function piecewise(normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\r\n * Normalizers by mapping methods.\r\n */\n\n\nvar normalizers = {\n  linear: function linear(value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function piecewise(value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function category(value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\r\n * List available visual types.\r\n *\r\n * @public\r\n * @return {Array.<string>}\r\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\r\n * @public\r\n */\n\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\r\n * @public\r\n */\n\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\r\n * Convinent method.\r\n * Visual can be Object or Array or primary type.\r\n *\r\n * @public\r\n */\n\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\r\n * @public\r\n * @param {Object} obj\r\n * @return {Object} new object containers visual values.\r\n *                 If no visuals, return null.\r\n */\n\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\r\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\r\n *\r\n * @public\r\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\r\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\r\n * @return {Array.<string>} Sorted visual types.\r\n */\n\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\r\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\r\n * Other visuals are only depends on themself.\r\n *\r\n * @public\r\n * @param {string} visualType1\r\n * @param {string} visualType2\r\n * @return {boolean}\r\n */\n\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\r\n * @param {number} value\r\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\r\n *                         Always from small to big.\r\n * @param {boolean} [findClosestWhenOutside=false]\r\n * @return {number} index\r\n */\n\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nvar _default = VisualMapping;\nmodule.exports = _default;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/echarts/lib/visual/VisualMapping.js"],"names":["zrUtil","require","zrColor","_number","linearMap","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_doMap","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","constructor","mapValueToVisual","value","normalized","getNormalizer","bind","color","makeApplyVisual","isNormalized","doMapCategory","call","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","opacity","makeDoMap","liftZ","symbol","getter","setter","symbolCfg","isString","name","hasOwnProperty","doMapToArray","symbolSize","pieceList","hasSpecialVisual","piece","index","originIndex","visual","categoryMap","cate","isArray","visualArr","v","setVisualToOption","i","length","pop","isCategory","push","doNotNeedPair","applyValue","Math","round","loop","sourceExtent","pieceIndex","findPieceIndex","map","item","parse","noop","listVisualTypes","visualTypes","handler","key","addVisualHandler","isValidType","eachVisual","callback","context","mapVisual","isPrimary","newVisual","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","types","slice","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findClosestWhenOutside","possibleI","abs","Infinity","len","pieceValue","updatePossible","interval","close","littleThan","val","newAbs","a","b","_default","module","exports"],"mappings":"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","sourcesContent":["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\nvar zrUtil = require(\"zrender/lib/core/util\");\r\n\r\nvar zrColor = require(\"zrender/lib/tool/color\");\r\n\r\nvar _number = require(\"../util/number\");\r\n\r\nvar linearMap = _number.linearMap;\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nvar each = zrUtil.each;\r\nvar isObject = zrUtil.isObject;\r\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\r\n/**\r\n * @param {Object} option\r\n * @param {string} [option.type] See visualHandlers.\r\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\r\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\r\n *                                              required when mappingMethod is 'linear'\r\n * @param {Array.<Object>=} [option.pieceList] [\r\n *                                             {value: someValue},\r\n *                                             {interval: [min1, max1], visual: {...}},\r\n *                                             {interval: [min2, max2]}\r\n *                                             ],\r\n *                                            required when mappingMethod is 'piecewise'.\r\n *                                            Visual for only each piece can be specified.\r\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\r\n *                                            required when mappingMethod is 'category'.\r\n *                                            If no option.categories, categories is set\r\n *                                            as [0, 1, 2, ...].\r\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\r\n * @param {(Array|Object|*)} [option.visual]  Visual data.\r\n *                                            when mappingMethod is 'category',\r\n *                                            visual data can be array or object\r\n *                                            (like: {cate1: '#222', none: '#fff'})\r\n *                                            or primary types (which represents\r\n *                                            defualt category visual), otherwise visual\r\n *                                            can be array or primary (which will be\r\n *                                            normalized to array).\r\n *\r\n */\r\n\r\nvar VisualMapping = function (option) {\r\n  var mappingMethod = option.mappingMethod;\r\n  var visualType = option.type;\r\n  /**\r\n   * @readOnly\r\n   * @type {Object}\r\n   */\r\n\r\n  var thisOption = this.option = zrUtil.clone(option);\r\n  /**\r\n   * @readOnly\r\n   * @type {string}\r\n   */\r\n\r\n  this.type = visualType;\r\n  /**\r\n   * @readOnly\r\n   * @type {string}\r\n   */\r\n\r\n  this.mappingMethod = mappingMethod;\r\n  /**\r\n   * @private\r\n   * @type {Function}\r\n   */\r\n\r\n  this._normalizeData = normalizers[mappingMethod];\r\n  var visualHandler = visualHandlers[visualType];\r\n  /**\r\n   * @public\r\n   * @type {Function}\r\n   */\r\n\r\n  this.applyVisual = visualHandler.applyVisual;\r\n  /**\r\n   * @public\r\n   * @type {Function}\r\n   */\r\n\r\n  this.getColorMapper = visualHandler.getColorMapper;\r\n  /**\r\n   * @private\r\n   * @type {Function}\r\n   */\r\n\r\n  this._doMap = visualHandler._doMap[mappingMethod];\r\n\r\n  if (mappingMethod === 'piecewise') {\r\n    normalizeVisualRange(thisOption);\r\n    preprocessForPiecewise(thisOption);\r\n  } else if (mappingMethod === 'category') {\r\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\r\n    // which need no more preprocess except normalize visual.\r\n    : normalizeVisualRange(thisOption, true);\r\n  } else {\r\n    // mappingMethod === 'linear' or 'fixed'\r\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\r\n    normalizeVisualRange(thisOption);\r\n  }\r\n};\r\n\r\nVisualMapping.prototype = {\r\n  constructor: VisualMapping,\r\n  mapValueToVisual: function (value) {\r\n    var normalized = this._normalizeData(value);\r\n\r\n    return this._doMap(normalized, value);\r\n  },\r\n  getNormalizer: function () {\r\n    return zrUtil.bind(this._normalizeData, this);\r\n  }\r\n};\r\nvar visualHandlers = VisualMapping.visualHandlers = {\r\n  color: {\r\n    applyVisual: makeApplyVisual('color'),\r\n\r\n    /**\r\n     * Create a mapper function\r\n     * @return {Function}\r\n     */\r\n    getColorMapper: function () {\r\n      var thisOption = this.option;\r\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\r\n        !isNormalized && (value = this._normalizeData(value));\r\n        return doMapCategory.call(this, value);\r\n      } : function (value, isNormalized, out) {\r\n        // If output rgb array\r\n        // which will be much faster and useful in pixel manipulation\r\n        var returnRGBArray = !!out;\r\n        !isNormalized && (value = this._normalizeData(value));\r\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\r\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\r\n      }, this);\r\n    },\r\n    _doMap: {\r\n      linear: function (normalized) {\r\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\r\n      },\r\n      category: doMapCategory,\r\n      piecewise: function (normalized, value) {\r\n        var result = getSpecifiedVisual.call(this, value);\r\n\r\n        if (result == null) {\r\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\r\n        }\r\n\r\n        return result;\r\n      },\r\n      fixed: doMapFixed\r\n    }\r\n  },\r\n  colorHue: makePartialColorVisualHandler(function (color, value) {\r\n    return zrColor.modifyHSL(color, value);\r\n  }),\r\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\r\n    return zrColor.modifyHSL(color, null, value);\r\n  }),\r\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\r\n    return zrColor.modifyHSL(color, null, null, value);\r\n  }),\r\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\r\n    return zrColor.modifyAlpha(color, value);\r\n  }),\r\n  opacity: {\r\n    applyVisual: makeApplyVisual('opacity'),\r\n    _doMap: makeDoMap([0, 1])\r\n  },\r\n  liftZ: {\r\n    applyVisual: makeApplyVisual('liftZ'),\r\n    _doMap: {\r\n      linear: doMapFixed,\r\n      category: doMapFixed,\r\n      piecewise: doMapFixed,\r\n      fixed: doMapFixed\r\n    }\r\n  },\r\n  symbol: {\r\n    applyVisual: function (value, getter, setter) {\r\n      var symbolCfg = this.mapValueToVisual(value);\r\n\r\n      if (zrUtil.isString(symbolCfg)) {\r\n        setter('symbol', symbolCfg);\r\n      } else if (isObject(symbolCfg)) {\r\n        for (var name in symbolCfg) {\r\n          if (symbolCfg.hasOwnProperty(name)) {\r\n            setter(name, symbolCfg[name]);\r\n          }\r\n        }\r\n      }\r\n    },\r\n    _doMap: {\r\n      linear: doMapToArray,\r\n      category: doMapCategory,\r\n      piecewise: function (normalized, value) {\r\n        var result = getSpecifiedVisual.call(this, value);\r\n\r\n        if (result == null) {\r\n          result = doMapToArray.call(this, normalized);\r\n        }\r\n\r\n        return result;\r\n      },\r\n      fixed: doMapFixed\r\n    }\r\n  },\r\n  symbolSize: {\r\n    applyVisual: makeApplyVisual('symbolSize'),\r\n    _doMap: makeDoMap([0, 1])\r\n  }\r\n};\r\n\r\nfunction preprocessForPiecewise(thisOption) {\r\n  var pieceList = thisOption.pieceList;\r\n  thisOption.hasSpecialVisual = false;\r\n  zrUtil.each(pieceList, function (piece, index) {\r\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\r\n    // a visual range, so it does not need to be normalized.\r\n\r\n    if (piece.visual != null) {\r\n      thisOption.hasSpecialVisual = true;\r\n    }\r\n  });\r\n}\r\n\r\nfunction preprocessForSpecifiedCategory(thisOption) {\r\n  // Hash categories.\r\n  var categories = thisOption.categories;\r\n  var visual = thisOption.visual;\r\n  var categoryMap = thisOption.categoryMap = {};\r\n  each(categories, function (cate, index) {\r\n    categoryMap[cate] = index;\r\n  }); // Process visual map input.\r\n\r\n  if (!zrUtil.isArray(visual)) {\r\n    var visualArr = [];\r\n\r\n    if (zrUtil.isObject(visual)) {\r\n      each(visual, function (v, cate) {\r\n        var index = categoryMap[cate];\r\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\r\n      });\r\n    } else {\r\n      // Is primary type, represents default visual.\r\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\r\n    }\r\n\r\n    visual = setVisualToOption(thisOption, visualArr);\r\n  } // Remove categories that has no visual,\r\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\r\n\r\n\r\n  for (var i = categories.length - 1; i >= 0; i--) {\r\n    if (visual[i] == null) {\r\n      delete categoryMap[categories[i]];\r\n      categories.pop();\r\n    }\r\n  }\r\n}\r\n\r\nfunction normalizeVisualRange(thisOption, isCategory) {\r\n  var visual = thisOption.visual;\r\n  var visualArr = [];\r\n\r\n  if (zrUtil.isObject(visual)) {\r\n    each(visual, function (v) {\r\n      visualArr.push(v);\r\n    });\r\n  } else if (visual != null) {\r\n    visualArr.push(visual);\r\n  }\r\n\r\n  var doNotNeedPair = {\r\n    color: 1,\r\n    symbol: 1\r\n  };\r\n\r\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\r\n    // Do not care visualArr.length === 0, which is illegal.\r\n    visualArr[1] = visualArr[0];\r\n  }\r\n\r\n  setVisualToOption(thisOption, visualArr);\r\n}\r\n\r\nfunction makePartialColorVisualHandler(applyValue) {\r\n  return {\r\n    applyVisual: function (value, getter, setter) {\r\n      value = this.mapValueToVisual(value); // Must not be array value\r\n\r\n      setter('color', applyValue(getter('color'), value));\r\n    },\r\n    _doMap: makeDoMap([0, 1])\r\n  };\r\n}\r\n\r\nfunction doMapToArray(normalized) {\r\n  var visual = this.option.visual;\r\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\r\n}\r\n\r\nfunction makeApplyVisual(visualType) {\r\n  return function (value, getter, setter) {\r\n    setter(visualType, this.mapValueToVisual(value));\r\n  };\r\n}\r\n\r\nfunction doMapCategory(normalized) {\r\n  var visual = this.option.visual;\r\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\r\n}\r\n\r\nfunction doMapFixed() {\r\n  return this.option.visual[0];\r\n}\r\n\r\nfunction makeDoMap(sourceExtent) {\r\n  return {\r\n    linear: function (normalized) {\r\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\r\n    },\r\n    category: doMapCategory,\r\n    piecewise: function (normalized, value) {\r\n      var result = getSpecifiedVisual.call(this, value);\r\n\r\n      if (result == null) {\r\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\r\n      }\r\n\r\n      return result;\r\n    },\r\n    fixed: doMapFixed\r\n  };\r\n}\r\n\r\nfunction getSpecifiedVisual(value) {\r\n  var thisOption = this.option;\r\n  var pieceList = thisOption.pieceList;\r\n\r\n  if (thisOption.hasSpecialVisual) {\r\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\r\n    var piece = pieceList[pieceIndex];\r\n\r\n    if (piece && piece.visual) {\r\n      return piece.visual[this.type];\r\n    }\r\n  }\r\n}\r\n\r\nfunction setVisualToOption(thisOption, visualArr) {\r\n  thisOption.visual = visualArr;\r\n\r\n  if (thisOption.type === 'color') {\r\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\r\n      return zrColor.parse(item);\r\n    });\r\n  }\r\n\r\n  return visualArr;\r\n}\r\n/**\r\n * Normalizers by mapping methods.\r\n */\r\n\r\n\r\nvar normalizers = {\r\n  linear: function (value) {\r\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\r\n  },\r\n  piecewise: function (value) {\r\n    var pieceList = this.option.pieceList;\r\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\r\n\r\n    if (pieceIndex != null) {\r\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\r\n    }\r\n  },\r\n  category: function (value) {\r\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\r\n\r\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\r\n  },\r\n  fixed: zrUtil.noop\r\n};\r\n/**\r\n * List available visual types.\r\n *\r\n * @public\r\n * @return {Array.<string>}\r\n */\r\n\r\nVisualMapping.listVisualTypes = function () {\r\n  var visualTypes = [];\r\n  zrUtil.each(visualHandlers, function (handler, key) {\r\n    visualTypes.push(key);\r\n  });\r\n  return visualTypes;\r\n};\r\n/**\r\n * @public\r\n */\r\n\r\n\r\nVisualMapping.addVisualHandler = function (name, handler) {\r\n  visualHandlers[name] = handler;\r\n};\r\n/**\r\n * @public\r\n */\r\n\r\n\r\nVisualMapping.isValidType = function (visualType) {\r\n  return visualHandlers.hasOwnProperty(visualType);\r\n};\r\n/**\r\n * Convinent method.\r\n * Visual can be Object or Array or primary type.\r\n *\r\n * @public\r\n */\r\n\r\n\r\nVisualMapping.eachVisual = function (visual, callback, context) {\r\n  if (zrUtil.isObject(visual)) {\r\n    zrUtil.each(visual, callback, context);\r\n  } else {\r\n    callback.call(context, visual);\r\n  }\r\n};\r\n\r\nVisualMapping.mapVisual = function (visual, callback, context) {\r\n  var isPrimary;\r\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\r\n  VisualMapping.eachVisual(visual, function (v, key) {\r\n    var newVal = callback.call(context, v, key);\r\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\r\n  });\r\n  return newVisual;\r\n};\r\n/**\r\n * @public\r\n * @param {Object} obj\r\n * @return {Object} new object containers visual values.\r\n *                 If no visuals, return null.\r\n */\r\n\r\n\r\nVisualMapping.retrieveVisuals = function (obj) {\r\n  var ret = {};\r\n  var hasVisual;\r\n  obj && each(visualHandlers, function (h, visualType) {\r\n    if (obj.hasOwnProperty(visualType)) {\r\n      ret[visualType] = obj[visualType];\r\n      hasVisual = true;\r\n    }\r\n  });\r\n  return hasVisual ? ret : null;\r\n};\r\n/**\r\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\r\n *\r\n * @public\r\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\r\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\r\n * @return {Array.<string>} Sorted visual types.\r\n */\r\n\r\n\r\nVisualMapping.prepareVisualTypes = function (visualTypes) {\r\n  if (isObject(visualTypes)) {\r\n    var types = [];\r\n    each(visualTypes, function (item, type) {\r\n      types.push(type);\r\n    });\r\n    visualTypes = types;\r\n  } else if (zrUtil.isArray(visualTypes)) {\r\n    visualTypes = visualTypes.slice();\r\n  } else {\r\n    return [];\r\n  }\r\n\r\n  visualTypes.sort(function (type1, type2) {\r\n    // color should be front of colorSaturation, colorAlpha, ...\r\n    // symbol and symbolSize do not matter.\r\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\r\n  });\r\n  return visualTypes;\r\n};\r\n/**\r\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\r\n * Other visuals are only depends on themself.\r\n *\r\n * @public\r\n * @param {string} visualType1\r\n * @param {string} visualType2\r\n * @return {boolean}\r\n */\r\n\r\n\r\nVisualMapping.dependsOn = function (visualType1, visualType2) {\r\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\r\n};\r\n/**\r\n * @param {number} value\r\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\r\n *                         Always from small to big.\r\n * @param {boolean} [findClosestWhenOutside=false]\r\n * @return {number} index\r\n */\r\n\r\n\r\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\r\n  var possibleI;\r\n  var abs = Infinity; // value has the higher priority.\r\n\r\n  for (var i = 0, len = pieceList.length; i < len; i++) {\r\n    var pieceValue = pieceList[i].value;\r\n\r\n    if (pieceValue != null) {\r\n      if (pieceValue === value // FIXME\r\n      // It is supposed to compare value according to value type of dimension,\r\n      // but currently value type can exactly be string or number.\r\n      // Compromise for numeric-like string (like '12'), especially\r\n      // in the case that visualMap.categories is ['22', '33'].\r\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\r\n        return i;\r\n      }\r\n\r\n      findClosestWhenOutside && updatePossible(pieceValue, i);\r\n    }\r\n  }\r\n\r\n  for (var i = 0, len = pieceList.length; i < len; i++) {\r\n    var piece = pieceList[i];\r\n    var interval = piece.interval;\r\n    var close = piece.close;\r\n\r\n    if (interval) {\r\n      if (interval[0] === -Infinity) {\r\n        if (littleThan(close[1], value, interval[1])) {\r\n          return i;\r\n        }\r\n      } else if (interval[1] === Infinity) {\r\n        if (littleThan(close[0], interval[0], value)) {\r\n          return i;\r\n        }\r\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\r\n        return i;\r\n      }\r\n\r\n      findClosestWhenOutside && updatePossible(interval[0], i);\r\n      findClosestWhenOutside && updatePossible(interval[1], i);\r\n    }\r\n  }\r\n\r\n  if (findClosestWhenOutside) {\r\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\r\n  }\r\n\r\n  function updatePossible(val, index) {\r\n    var newAbs = Math.abs(val - value);\r\n\r\n    if (newAbs < abs) {\r\n      abs = newAbs;\r\n      possibleI = index;\r\n    }\r\n  }\r\n};\r\n\r\nfunction littleThan(close, a, b) {\r\n  return close ? a <= b : a < b;\r\n}\r\n\r\nvar _default = VisualMapping;\r\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}