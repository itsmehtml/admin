{"ast":null,"code":"var util = require(\"./core/util\");\n\nvar vec2 = require(\"./core/vector\");\n\nvar Draggable = require(\"./mixin/Draggable\");\n\nvar Eventful = require(\"./mixin/Eventful\");\n\nvar eventTool = require(\"./core/event\");\n\nvar GestureMgr = require(\"./core/GestureMgr\");\n/**\r\n * [The interface between `Handler` and `HandlerProxy`]:\r\n *\r\n * The default `HandlerProxy` only support the common standard web environment\r\n * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).\r\n * But `HandlerProxy` can be replaced to support more non-standard environment\r\n * (e.g., mini app), or to support more feature that the default `HandlerProxy`\r\n * not provided (like echarts-gl did).\r\n * So the interface between `Handler` and `HandlerProxy` should be stable. Do not\r\n * make break changes util inevitable. The interface include the public methods\r\n * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`\r\n * drives `Handler`.\r\n */\n\n/**\r\n * [Drag outside]:\r\n *\r\n * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the\r\n * zrender area when dragging. That is important for the improvement of the user experience\r\n * when dragging something near the boundary without being terminated unexpectedly.\r\n *\r\n * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`\r\n * to resolve this issue. But some drawbacks of it is described in\r\n * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899\r\n *\r\n * Instead, we referenced the specifications:\r\n * https://www.w3.org/TR/touch-events/#the-touchmove-event\r\n * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove\r\n * where the the mousemove/touchmove can be continue to fire if the user began a drag\r\n * operation and the pointer has left the boundary. (for the mouse event, browsers\r\n * only do it on `document` and when the pointer has left the boundary of the browser.)\r\n *\r\n * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging\r\n * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue\r\n * to fire until release the pointer. That is implemented by listen to those event on\r\n * `document`.\r\n * If we implement some other `HandlerProxy` only for touch device, that would be easier.\r\n * The touch event support this feature by default.\r\n *\r\n * Note:\r\n * There might be some cases that the mouse event can not be\r\n * received on `document`. For example,\r\n * (A) `useCapture` is not supported and some user defined event listeners on the ancestor\r\n * of zr dom throw Error .\r\n * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of\r\n * zr dom call `stopPropagation`.\r\n * In these cases, the `mousemove` event might be keep triggered event\r\n * if the mouse is released. We try to reduce the side-effect in those cases.\r\n * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.\r\n *\r\n * Note:\r\n * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to\r\n * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event\r\n * target is not zrender dom. Becuase it is dangerous to enable users to call them in\r\n * `document` capture phase to prevent the propagation to any listener of the webpage.\r\n * But they are needed to work when the pointer inside the zrender dom.\r\n */\n\n\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which,\n    stop: stopEvent\n  };\n}\n\nfunction stopEvent() {\n  eventTool.stop(this.event);\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\r\n * @alias module:zrender/Handler\r\n * @constructor\r\n * @extends module:zrender/mixin/Eventful\r\n * @param {module:zrender/Storage} storage Storage instance.\r\n * @param {module:zrender/Painter} painter Painter instance.\r\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\r\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\r\n */\n\nvar Handler = function Handler(storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\r\n   * Proxy of event. can be Dom, WebGLSurface, etc.\r\n   */\n\n  this.proxy = null;\n  /**\r\n   * {target, topTarget, x, y}\r\n   * @private\r\n   * @type {Object}\r\n   */\n\n  this._hovered = {};\n  /**\r\n   * @private\r\n   * @type {Date}\r\n   */\n\n  this._lastTouchMoment;\n  /**\r\n   * @private\r\n   * @type {number}\r\n   */\n\n  this._lastX;\n  /**\r\n   * @private\r\n   * @type {number}\r\n   */\n\n  this._lastY;\n  /**\r\n   * @private\r\n   * @type {module:zrender/core/GestureMgr}\r\n   */\n\n  this._gestureMgr;\n  Draggable.call(this);\n  this.setHandlerProxy(proxy);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  setHandlerProxy: function setHandlerProxy(proxy) {\n    if (this.proxy) {\n      this.proxy.dispose();\n    }\n\n    if (proxy) {\n      util.each(handlerNames, function (name) {\n        proxy.on && proxy.on(name, this[name], this);\n      }, this); // Attach handler\n\n      proxy.handler = this;\n    }\n\n    this.proxy = proxy;\n  },\n  mousemove: function mousemove(event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var isOutside = isOutsideBoundary(this, x, y);\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = isOutside ? {\n      x: x,\n      y: y\n    } : this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function mouseout(event) {\n    var eventControl = event.zrEventControl;\n    var zrIsToLocalDOM = event.zrIsToLocalDOM;\n\n    if (eventControl !== 'only_globalout') {\n      this.dispatchToElement(this._hovered, 'mouseout', event);\n    }\n\n    if (eventControl !== 'no_globalout') {\n      // FIXME: if the pointer moving from the extra doms to realy \"outside\",\n      // the `globalout` should have been triggered. But currently not.\n      !zrIsToLocalDOM && this.trigger('globalout', {\n        type: 'globalout',\n        event: event\n      });\n    }\n  },\n\n  /**\r\n   * Resize\r\n   */\n  resize: function resize(event) {\n    this._hovered = {};\n  },\n\n  /**\r\n   * Dispatch event\r\n   * @param {string} eventName\r\n   * @param {event=} eventArgs\r\n   */\n  dispatch: function dispatch(eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\r\n   * Dispose\r\n   */\n  dispose: function dispose() {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\r\n   * 设置默认的cursor style\r\n   * @param {string} [cursorStyle='default'] 例如 crosshair\r\n   */\n  setCursorStyle: function setCursorStyle(cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\r\n   * 事件分发代理\r\n   *\r\n   * @private\r\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\r\n   * @param {string} eventName 事件名称\r\n   * @param {Object} event 事件对象\r\n   */\n  dispatchToElement: function dispatchToElement(targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] === 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\r\n   * @private\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {module:zrender/graphic/Displayable} exclude\r\n   * @return {model:zrender/Element}\r\n   * @method\r\n   */\n  findHover: function findHover(x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  },\n  processGesture: function processGesture(event, stage) {\n    if (!this._gestureMgr) {\n      this._gestureMgr = new GestureMgr();\n    }\n\n    var gestureMgr = this._gestureMgr;\n    stage === 'start' && gestureMgr.clear();\n    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);\n    stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n    if (gestureInfo) {\n      var type = gestureInfo.type;\n      event.gestureEvent = type;\n      this.dispatchToElement({\n        target: gestureInfo.target\n      }, type, gestureInfo.event);\n    }\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var isOutside = isOutsideBoundary(this, x, y);\n    var hovered;\n    var hoveredTarget;\n\n    if (name !== 'mouseup' || !isOutside) {\n      // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n      hovered = this.findHover(x, y);\n      hoveredTarget = hovered.target;\n    }\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mouseup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n/**\r\n * See [Drag outside].\r\n */\n\n\nfunction isOutsideBoundary(handlerInstance, x, y) {\n  var painter = handlerInstance.painter;\n  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;","map":{"version":3,"sources":["C:/Users/user/Desktop/Admin/node_modules/zrender/lib/Handler.js"],"names":["util","require","vec2","Draggable","Eventful","eventTool","GestureMgr","SILENT","makeEventPacket","eveType","targetInfo","event","type","target","topTarget","cancelBubble","offsetX","zrX","offsetY","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","zrByTouch","which","stop","stopEvent","EmptyProxy","prototype","dispose","handlerNames","Handler","storage","painter","proxy","painterRoot","call","_hovered","_lastTouchMoment","_lastX","_lastY","_gestureMgr","setHandlerProxy","constructor","each","name","on","handler","mousemove","x","y","isOutside","isOutsideBoundary","lastHovered","lastHoveredTarget","__zr","findHover","hovered","hoveredTarget","setCursor","cursor","dispatchToElement","mouseout","eventControl","zrEventControl","zrIsToLocalDOM","trigger","resize","dispatch","eventName","eventArgs","setCursorStyle","cursorStyle","el","silent","eventHandler","eventPacket","parent","eachOtherLayer","layer","exclude","list","getDisplayList","out","i","length","hoverCheckResult","ignore","isHover","processGesture","stage","gestureMgr","clear","gestureInfo","recognize","dom","_downEl","_downPoint","_upEl","dist","displayable","rectHover","isSilent","clipPath","contain","handlerInstance","getWidth","getHeight","mixin","_default","module","exports"],"mappings":"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","sourcesContent":["var util = require(\"./core/util\");\r\n\r\nvar vec2 = require(\"./core/vector\");\r\n\r\nvar Draggable = require(\"./mixin/Draggable\");\r\n\r\nvar Eventful = require(\"./mixin/Eventful\");\r\n\r\nvar eventTool = require(\"./core/event\");\r\n\r\nvar GestureMgr = require(\"./core/GestureMgr\");\r\n\r\n/**\r\n * [The interface between `Handler` and `HandlerProxy`]:\r\n *\r\n * The default `HandlerProxy` only support the common standard web environment\r\n * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).\r\n * But `HandlerProxy` can be replaced to support more non-standard environment\r\n * (e.g., mini app), or to support more feature that the default `HandlerProxy`\r\n * not provided (like echarts-gl did).\r\n * So the interface between `Handler` and `HandlerProxy` should be stable. Do not\r\n * make break changes util inevitable. The interface include the public methods\r\n * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`\r\n * drives `Handler`.\r\n */\r\n\r\n/**\r\n * [Drag outside]:\r\n *\r\n * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the\r\n * zrender area when dragging. That is important for the improvement of the user experience\r\n * when dragging something near the boundary without being terminated unexpectedly.\r\n *\r\n * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`\r\n * to resolve this issue. But some drawbacks of it is described in\r\n * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899\r\n *\r\n * Instead, we referenced the specifications:\r\n * https://www.w3.org/TR/touch-events/#the-touchmove-event\r\n * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove\r\n * where the the mousemove/touchmove can be continue to fire if the user began a drag\r\n * operation and the pointer has left the boundary. (for the mouse event, browsers\r\n * only do it on `document` and when the pointer has left the boundary of the browser.)\r\n *\r\n * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging\r\n * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue\r\n * to fire until release the pointer. That is implemented by listen to those event on\r\n * `document`.\r\n * If we implement some other `HandlerProxy` only for touch device, that would be easier.\r\n * The touch event support this feature by default.\r\n *\r\n * Note:\r\n * There might be some cases that the mouse event can not be\r\n * received on `document`. For example,\r\n * (A) `useCapture` is not supported and some user defined event listeners on the ancestor\r\n * of zr dom throw Error .\r\n * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of\r\n * zr dom call `stopPropagation`.\r\n * In these cases, the `mousemove` event might be keep triggered event\r\n * if the mouse is released. We try to reduce the side-effect in those cases.\r\n * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.\r\n *\r\n * Note:\r\n * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to\r\n * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event\r\n * target is not zrender dom. Becuase it is dangerous to enable users to call them in\r\n * `document` capture phase to prevent the propagation to any listener of the webpage.\r\n * But they are needed to work when the pointer inside the zrender dom.\r\n */\r\nvar SILENT = 'silent';\r\n\r\nfunction makeEventPacket(eveType, targetInfo, event) {\r\n  return {\r\n    type: eveType,\r\n    event: event,\r\n    // target can only be an element that is not silent.\r\n    target: targetInfo.target,\r\n    // topTarget can be a silent element.\r\n    topTarget: targetInfo.topTarget,\r\n    cancelBubble: false,\r\n    offsetX: event.zrX,\r\n    offsetY: event.zrY,\r\n    gestureEvent: event.gestureEvent,\r\n    pinchX: event.pinchX,\r\n    pinchY: event.pinchY,\r\n    pinchScale: event.pinchScale,\r\n    wheelDelta: event.zrDelta,\r\n    zrByTouch: event.zrByTouch,\r\n    which: event.which,\r\n    stop: stopEvent\r\n  };\r\n}\r\n\r\nfunction stopEvent() {\r\n  eventTool.stop(this.event);\r\n}\r\n\r\nfunction EmptyProxy() {}\r\n\r\nEmptyProxy.prototype.dispose = function () {};\r\n\r\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\r\n/**\r\n * @alias module:zrender/Handler\r\n * @constructor\r\n * @extends module:zrender/mixin/Eventful\r\n * @param {module:zrender/Storage} storage Storage instance.\r\n * @param {module:zrender/Painter} painter Painter instance.\r\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\r\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\r\n */\r\n\r\nvar Handler = function (storage, painter, proxy, painterRoot) {\r\n  Eventful.call(this);\r\n  this.storage = storage;\r\n  this.painter = painter;\r\n  this.painterRoot = painterRoot;\r\n  proxy = proxy || new EmptyProxy();\r\n  /**\r\n   * Proxy of event. can be Dom, WebGLSurface, etc.\r\n   */\r\n\r\n  this.proxy = null;\r\n  /**\r\n   * {target, topTarget, x, y}\r\n   * @private\r\n   * @type {Object}\r\n   */\r\n\r\n  this._hovered = {};\r\n  /**\r\n   * @private\r\n   * @type {Date}\r\n   */\r\n\r\n  this._lastTouchMoment;\r\n  /**\r\n   * @private\r\n   * @type {number}\r\n   */\r\n\r\n  this._lastX;\r\n  /**\r\n   * @private\r\n   * @type {number}\r\n   */\r\n\r\n  this._lastY;\r\n  /**\r\n   * @private\r\n   * @type {module:zrender/core/GestureMgr}\r\n   */\r\n\r\n  this._gestureMgr;\r\n  Draggable.call(this);\r\n  this.setHandlerProxy(proxy);\r\n};\r\n\r\nHandler.prototype = {\r\n  constructor: Handler,\r\n  setHandlerProxy: function (proxy) {\r\n    if (this.proxy) {\r\n      this.proxy.dispose();\r\n    }\r\n\r\n    if (proxy) {\r\n      util.each(handlerNames, function (name) {\r\n        proxy.on && proxy.on(name, this[name], this);\r\n      }, this); // Attach handler\r\n\r\n      proxy.handler = this;\r\n    }\r\n\r\n    this.proxy = proxy;\r\n  },\r\n  mousemove: function (event) {\r\n    var x = event.zrX;\r\n    var y = event.zrY;\r\n    var isOutside = isOutsideBoundary(this, x, y);\r\n    var lastHovered = this._hovered;\r\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\r\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\r\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\r\n    // See #6198.\r\n\r\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\r\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\r\n      lastHoveredTarget = lastHovered.target;\r\n    }\r\n\r\n    var hovered = this._hovered = isOutside ? {\r\n      x: x,\r\n      y: y\r\n    } : this.findHover(x, y);\r\n    var hoveredTarget = hovered.target;\r\n    var proxy = this.proxy;\r\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\r\n\r\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\r\n      this.dispatchToElement(lastHovered, 'mouseout', event);\r\n    } // Mouse moving on one element\r\n\r\n\r\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\r\n\r\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\r\n      this.dispatchToElement(hovered, 'mouseover', event);\r\n    }\r\n  },\r\n  mouseout: function (event) {\r\n    var eventControl = event.zrEventControl;\r\n    var zrIsToLocalDOM = event.zrIsToLocalDOM;\r\n\r\n    if (eventControl !== 'only_globalout') {\r\n      this.dispatchToElement(this._hovered, 'mouseout', event);\r\n    }\r\n\r\n    if (eventControl !== 'no_globalout') {\r\n      // FIXME: if the pointer moving from the extra doms to realy \"outside\",\r\n      // the `globalout` should have been triggered. But currently not.\r\n      !zrIsToLocalDOM && this.trigger('globalout', {\r\n        type: 'globalout',\r\n        event: event\r\n      });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Resize\r\n   */\r\n  resize: function (event) {\r\n    this._hovered = {};\r\n  },\r\n\r\n  /**\r\n   * Dispatch event\r\n   * @param {string} eventName\r\n   * @param {event=} eventArgs\r\n   */\r\n  dispatch: function (eventName, eventArgs) {\r\n    var handler = this[eventName];\r\n    handler && handler.call(this, eventArgs);\r\n  },\r\n\r\n  /**\r\n   * Dispose\r\n   */\r\n  dispose: function () {\r\n    this.proxy.dispose();\r\n    this.storage = this.proxy = this.painter = null;\r\n  },\r\n\r\n  /**\r\n   * 设置默认的cursor style\r\n   * @param {string} [cursorStyle='default'] 例如 crosshair\r\n   */\r\n  setCursorStyle: function (cursorStyle) {\r\n    var proxy = this.proxy;\r\n    proxy.setCursor && proxy.setCursor(cursorStyle);\r\n  },\r\n\r\n  /**\r\n   * 事件分发代理\r\n   *\r\n   * @private\r\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\r\n   * @param {string} eventName 事件名称\r\n   * @param {Object} event 事件对象\r\n   */\r\n  dispatchToElement: function (targetInfo, eventName, event) {\r\n    targetInfo = targetInfo || {};\r\n    var el = targetInfo.target;\r\n\r\n    if (el && el.silent) {\r\n      return;\r\n    }\r\n\r\n    var eventHandler = 'on' + eventName;\r\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\r\n\r\n    while (el) {\r\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\r\n      el.trigger(eventName, eventPacket);\r\n      el = el.parent;\r\n\r\n      if (eventPacket.cancelBubble) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!eventPacket.cancelBubble) {\r\n      // 冒泡到顶级 zrender 对象\r\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\r\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\r\n\r\n      this.painter && this.painter.eachOtherLayer(function (layer) {\r\n        if (typeof layer[eventHandler] === 'function') {\r\n          layer[eventHandler].call(layer, eventPacket);\r\n        }\r\n\r\n        if (layer.trigger) {\r\n          layer.trigger(eventName, eventPacket);\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {module:zrender/graphic/Displayable} exclude\r\n   * @return {model:zrender/Element}\r\n   * @method\r\n   */\r\n  findHover: function (x, y, exclude) {\r\n    var list = this.storage.getDisplayList();\r\n    var out = {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    for (var i = list.length - 1; i >= 0; i--) {\r\n      var hoverCheckResult;\r\n\r\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\r\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\r\n        !out.topTarget && (out.topTarget = list[i]);\r\n\r\n        if (hoverCheckResult !== SILENT) {\r\n          out.target = list[i];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return out;\r\n  },\r\n  processGesture: function (event, stage) {\r\n    if (!this._gestureMgr) {\r\n      this._gestureMgr = new GestureMgr();\r\n    }\r\n\r\n    var gestureMgr = this._gestureMgr;\r\n    stage === 'start' && gestureMgr.clear();\r\n    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);\r\n    stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\r\n\r\n    if (gestureInfo) {\r\n      var type = gestureInfo.type;\r\n      event.gestureEvent = type;\r\n      this.dispatchToElement({\r\n        target: gestureInfo.target\r\n      }, type, gestureInfo.event);\r\n    }\r\n  }\r\n}; // Common handlers\r\n\r\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\r\n  Handler.prototype[name] = function (event) {\r\n    var x = event.zrX;\r\n    var y = event.zrY;\r\n    var isOutside = isOutsideBoundary(this, x, y);\r\n    var hovered;\r\n    var hoveredTarget;\r\n\r\n    if (name !== 'mouseup' || !isOutside) {\r\n      // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\r\n      hovered = this.findHover(x, y);\r\n      hoveredTarget = hovered.target;\r\n    }\r\n\r\n    if (name === 'mousedown') {\r\n      this._downEl = hoveredTarget;\r\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\r\n\r\n      this._upEl = hoveredTarget;\r\n    } else if (name === 'mouseup') {\r\n      this._upEl = hoveredTarget;\r\n    } else if (name === 'click') {\r\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\r\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\r\n      // which should be filtered, otherwise it will bring trouble to\r\n      // pan and zoom.\r\n      || !this._downPoint // Arbitrary value\r\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\r\n        return;\r\n      }\r\n\r\n      this._downPoint = null;\r\n    }\r\n\r\n    this.dispatchToElement(hovered, name, event);\r\n  };\r\n});\r\n\r\nfunction isHover(displayable, x, y) {\r\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\r\n    var el = displayable;\r\n    var isSilent;\r\n\r\n    while (el) {\r\n      // If clipped by ancestor.\r\n      // FIXME: If clipPath has neither stroke nor fill,\r\n      // el.clipPath.contain(x, y) will always return false.\r\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\r\n        return false;\r\n      }\r\n\r\n      if (el.silent) {\r\n        isSilent = true;\r\n      }\r\n\r\n      el = el.parent;\r\n    }\r\n\r\n    return isSilent ? SILENT : true;\r\n  }\r\n\r\n  return false;\r\n}\r\n/**\r\n * See [Drag outside].\r\n */\r\n\r\n\r\nfunction isOutsideBoundary(handlerInstance, x, y) {\r\n  var painter = handlerInstance.painter;\r\n  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();\r\n}\r\n\r\nutil.mixin(Handler, Eventful);\r\nutil.mixin(Handler, Draggable);\r\nvar _default = Handler;\r\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}