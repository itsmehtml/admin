{"ast":null,"code":"import _slicedToArray from \"C:/Users/user/Desktop/Admin/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"C:/Users/user/Desktop/Admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:/Users/user/Desktop/Admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject, Observable, merge, ReplaySubject, combineLatest, fromEvent } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, Renderer2, Output, EventEmitter, NgZone, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, distinctUntilChanged } from 'rxjs/operators';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar DraggableHelper = function DraggableHelper() {\n  _classCallCheck(this, DraggableHelper);\n\n  this.currentDrag = new Subject();\n};\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nDraggableHelper.ngInjectableDef = defineInjectable({\n  factory: function DraggableHelper_Factory() {\n    return new DraggableHelper();\n  },\n  token: DraggableHelper,\n  providedIn: \"root\"\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\r\n * ```html\r\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\r\n * <div mwlDraggable>Drag me!</div>\r\n * </div>\r\n * ```\r\n */\n\n\nvar DraggableScrollContainerDirective =\n/**\r\n * @hidden\r\n * @param {?} elementRef\r\n */\nfunction DraggableScrollContainerDirective(elementRef) {\n  _classCallCheck(this, DraggableScrollContainerDirective);\n\n  this.elementRef = elementRef;\n  /**\r\n   * Trigger the DragStart after a long touch in scrollable container when true\r\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\r\n   */\n\n  this.activeLongPressDrag = false;\n  /**\r\n   * Configuration of a long touch\r\n   * Duration in ms of a long touch before activating DragStart\r\n   * Delta of the\r\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\r\n   */\n\n  this.longPressConfig = {\n    duration: 300,\n    delta: 30\n  };\n};\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n};\n\nDraggableScrollContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n  inputs: {\n    activeLongPressDrag: \"activeLongPressDrag\",\n    longPressConfig: \"longPressConfig\"\n  }\n});\n/** @nocollapse */\n\nDraggableScrollContainerDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }];\n};\n\nDraggableScrollContainerDirective.propDecorators = {\n  activeLongPressDrag: [{\n    type: Input\n  }],\n  longPressConfig: [{\n    type: Input\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }];\n  }, {\n    activeLongPressDrag: [{\n      type: Input\n    }],\n    longPressConfig: [{\n      type: Input\n    }]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} renderer\r\n * @param {?} element\r\n * @param {?} classToAdd\r\n * @return {?}\r\n */\n\n\nfunction addClass(renderer, element, classToAdd) {\n  if (classToAdd) {\n    classToAdd.split(' ').forEach(\n    /**\r\n    * @param {?} className\r\n    * @return {?}\r\n    */\n    function (className) {\n      return renderer.addClass(element.nativeElement, className);\n    });\n  }\n}\n/**\r\n * @param {?} renderer\r\n * @param {?} element\r\n * @param {?} classToRemove\r\n * @return {?}\r\n */\n\n\nfunction removeClass(renderer, element, classToRemove) {\n  if (classToRemove) {\n    classToRemove.split(' ').forEach(\n    /**\r\n    * @param {?} className\r\n    * @return {?}\r\n    */\n    function (className) {\n      return renderer.removeClass(element.nativeElement, className);\n    });\n  }\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar DraggableDirective = /*#__PURE__*/function () {\n  /**\r\n   * @hidden\r\n   * @param {?} element\r\n   * @param {?} renderer\r\n   * @param {?} draggableHelper\r\n   * @param {?} zone\r\n   * @param {?} vcr\r\n   * @param {?} scrollContainer\r\n   * @param {?} document\r\n   */\n  function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    _classCallCheck(this, DraggableDirective);\n\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\r\n     * The axis along which the element is draggable\r\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\r\n     * Snap all drags to an x / y grid\r\n     */\n\n    this.dragSnapGrid = {};\n    /**\r\n     * Show a ghost element that shows the drag when dragging\r\n     */\n\n    this.ghostDragEnabled = true;\n    /**\r\n     * Show the original element when ghostDragEnabled is true\r\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\r\n     * The cursor to use when hovering over a draggable element\r\n     */\n\n    this.dragCursor = '';\n    /*\r\n       * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\r\n       */\n\n    this.autoScroll = {\n      margin: 20\n    };\n    /**\r\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\r\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\r\n     * Called when the element has started to be dragged.\r\n     * Only called after at least one mouse or touch move event.\r\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\r\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\r\n     * Called after the ghost element has been created\r\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\r\n     * Called when the element is being dragged\r\n     */\n\n    this.dragging = new EventEmitter();\n    /**\r\n     * Called after the element is dragged\r\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\r\n     * @hidden\r\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\r\n     * @hidden\r\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\r\n     * @hidden\r\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  _createClass(DraggableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this = this;\n\n      this.checkEventListeners();\n      /** @type {?} */\n\n      var pointerDragged$ = this.pointerDown$.pipe(filter(\n      /**\r\n      * @return {?}\r\n      */\n      function () {\n        return _this.canDrag();\n      }), mergeMap(\n      /**\r\n      * @param {?} pointerDownEvent\r\n      * @return {?}\r\n      */\n      function (pointerDownEvent) {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !_this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        } // hack to prevent text getting selected in safari while dragging\n\n        /** @type {?} */\n\n\n        var globalDragStyle = _this.renderer.createElement('style');\n\n        _this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n\n        _this.renderer.appendChild(globalDragStyle, _this.renderer.createText(\"\\n          body * {\\n           -moz-user-select: none;\\n           -ms-user-select: none;\\n           -webkit-user-select: none;\\n           user-select: none;\\n          }\\n        \"));\n\n        requestAnimationFrame(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          _this.document.head.appendChild(globalDragStyle);\n        });\n        /** @type {?} */\n\n        var startScrollPosition = _this.getScrollPosition();\n        /** @type {?} */\n\n\n        var scrollContainerScroll$ = new Observable(\n        /**\r\n        * @param {?} observer\r\n        * @return {?}\r\n        */\n        function (observer) {\n          /** @type {?} */\n          var scrollContainer = _this.scrollContainer ? _this.scrollContainer.elementRef.nativeElement : 'window';\n          return _this.renderer.listen(scrollContainer, 'scroll',\n          /**\r\n          * @param {?} e\r\n          * @return {?}\r\n          */\n          function (e) {\n            return observer.next(e);\n          });\n        }).pipe(startWith(startScrollPosition), map(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          return _this.getScrollPosition();\n        }));\n        /** @type {?} */\n\n        var currentDrag$ = new Subject();\n        /** @type {?} */\n\n        var cancelDrag$ = new ReplaySubject();\n\n        _this.zone.run(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          _this.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n        /** @type {?} */\n\n\n        var dragComplete$ = merge(_this.pointerUp$, _this.pointerDown$, cancelDrag$, _this.destroy$).pipe(share());\n        /** @type {?} */\n\n        var pointerMove = combineLatest([_this.pointerMove$, scrollContainerScroll$]).pipe(map(\n        /**\r\n        * @param {?} __0\r\n        * @return {?}\r\n        */\n        function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              pointerMoveEvent = _ref2[0],\n              scroll = _ref2[1];\n\n          return {\n            currentDrag$: currentDrag$,\n            transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n            transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n            clientX: pointerMoveEvent.clientX,\n            clientY: pointerMoveEvent.clientY,\n            scrollLeft: scroll.left,\n            scrollTop: scroll.top,\n            target: pointerMoveEvent.event.target\n          };\n        }), map(\n        /**\r\n        * @param {?} moveData\r\n        * @return {?}\r\n        */\n        function (moveData) {\n          if (_this.dragSnapGrid.x) {\n            moveData.transformX = Math.round(moveData.transformX / _this.dragSnapGrid.x) * _this.dragSnapGrid.x;\n          }\n\n          if (_this.dragSnapGrid.y) {\n            moveData.transformY = Math.round(moveData.transformY / _this.dragSnapGrid.y) * _this.dragSnapGrid.y;\n          }\n\n          return moveData;\n        }), map(\n        /**\r\n        * @param {?} moveData\r\n        * @return {?}\r\n        */\n        function (moveData) {\n          if (!_this.dragAxis.x) {\n            moveData.transformX = 0;\n          }\n\n          if (!_this.dragAxis.y) {\n            moveData.transformY = 0;\n          }\n\n          return moveData;\n        }), map(\n        /**\r\n        * @param {?} moveData\r\n        * @return {?}\r\n        */\n        function (moveData) {\n          /** @type {?} */\n          var scrollX = moveData.scrollLeft - startScrollPosition.left;\n          /** @type {?} */\n\n          var scrollY = moveData.scrollTop - startScrollPosition.top;\n          return Object.assign({}, moveData, {\n            x: moveData.transformX + scrollX,\n            y: moveData.transformY + scrollY\n          });\n        }), filter(\n        /**\r\n        * @param {?} __0\r\n        * @return {?}\r\n        */\n        function (_ref3) {\n          var x = _ref3.x,\n              y = _ref3.y,\n              transformX = _ref3.transformX,\n              transformY = _ref3.transformY;\n          return !_this.validateDrag || _this.validateDrag({\n            x: x,\n            y: y,\n            transform: {\n              x: transformX,\n              y: transformY\n            }\n          });\n        }), takeUntil(dragComplete$), share());\n        /** @type {?} */\n\n        var dragStarted$ = pointerMove.pipe(take(1), share());\n        /** @type {?} */\n\n        var dragEnded$ = pointerMove.pipe(takeLast(1), share());\n        dragStarted$.subscribe(\n        /**\r\n        * @param {?} __0\r\n        * @return {?}\r\n        */\n        function (_ref4) {\n          var clientX = _ref4.clientX,\n              clientY = _ref4.clientY,\n              x = _ref4.x,\n              y = _ref4.y;\n\n          _this.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this.dragStart.next({\n              cancelDrag$: cancelDrag$\n            });\n          });\n\n          _this.scroller = autoScroll([_this.scrollContainer ? _this.scrollContainer.elementRef.nativeElement : _this.document.defaultView], Object.assign({}, _this.autoScroll, {\n            /**\r\n            * @return {?}\r\n            */\n            autoScroll: function autoScroll() {\n              return true;\n            }\n          }));\n          addClass(_this.renderer, _this.element, _this.dragActiveClass);\n\n          if (_this.ghostDragEnabled) {\n            /** @type {?} */\n            var rect = _this.element.nativeElement.getBoundingClientRect();\n            /** @type {?} */\n\n\n            var clone =\n            /** @type {?} */\n            _this.element.nativeElement.cloneNode(true);\n\n            if (!_this.showOriginalElementWhileDragging) {\n              _this.renderer.setStyle(_this.element.nativeElement, 'visibility', 'hidden');\n            }\n\n            if (_this.ghostElementAppendTo) {\n              _this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              /** @type {?} */\n              _this.element.nativeElement.parentNode.insertBefore(clone, _this.element.nativeElement.nextSibling);\n            }\n\n            _this.ghostElement = clone;\n            _this.document.body.style.cursor = _this.dragCursor;\n\n            _this.setElementStyles(clone, {\n              position: 'fixed',\n              top: \"\".concat(rect.top, \"px\"),\n              left: \"\".concat(rect.left, \"px\"),\n              width: \"\".concat(rect.width, \"px\"),\n              height: \"\".concat(rect.height, \"px\"),\n              cursor: _this.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none'\n            });\n\n            if (_this.ghostElementTemplate) {\n              /** @type {?} */\n              var viewRef = _this.vcr.createEmbeddedView(_this.ghostElementTemplate);\n\n              clone.innerHTML = '';\n              viewRef.rootNodes.filter(\n              /**\r\n              * @param {?} node\r\n              * @return {?}\r\n              */\n              function (node) {\n                return node instanceof Node;\n              }).forEach(\n              /**\r\n              * @param {?} node\r\n              * @return {?}\r\n              */\n              function (node) {\n                clone.appendChild(node);\n              });\n              dragEnded$.subscribe(\n              /**\r\n              * @return {?}\r\n              */\n              function () {\n                _this.vcr.remove(_this.vcr.indexOf(viewRef));\n              });\n            }\n\n            _this.zone.run(\n            /**\r\n            * @return {?}\r\n            */\n            function () {\n              _this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n\n            dragEnded$.subscribe(\n            /**\r\n            * @return {?}\r\n            */\n            function () {\n              /** @type {?} */\n              clone.parentElement.removeChild(clone);\n              _this.ghostElement = null;\n\n              _this.renderer.setStyle(_this.element.nativeElement, 'visibility', '');\n            });\n          }\n\n          _this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n        dragEnded$.pipe(mergeMap(\n        /**\r\n        * @param {?} dragEndData\r\n        * @return {?}\r\n        */\n        function (dragEndData) {\n          /** @type {?} */\n          var dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n          /**\r\n          * @param {?} calledCount\r\n          * @return {?}\r\n          */\n          function (calledCount) {\n            return Object.assign({}, dragEndData, {\n              dragCancelled: calledCount > 0\n            });\n          }));\n          cancelDrag$.complete();\n          return dragEndData$;\n        })).subscribe(\n        /**\r\n        * @param {?} __0\r\n        * @return {?}\r\n        */\n        function (_ref5) {\n          var x = _ref5.x,\n              y = _ref5.y,\n              dragCancelled = _ref5.dragCancelled;\n\n          _this.scroller.destroy();\n\n          _this.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this.dragEnd.next({\n              x: x,\n              y: y,\n              dragCancelled: dragCancelled\n            });\n          });\n\n          removeClass(_this.renderer, _this.element, _this.dragActiveClass);\n          currentDrag$.complete();\n        });\n        merge(dragComplete$, dragEnded$).pipe(take(1)).subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          requestAnimationFrame(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this.document.head.removeChild(globalDragStyle);\n          });\n        });\n        return pointerMove;\n      }), share());\n      merge(pointerDragged$.pipe(take(1), map(\n      /**\r\n      * @param {?} value\r\n      * @return {?}\r\n      */\n      function (value) {\n        return [, value];\n      })), pointerDragged$.pipe(pairwise())).pipe(filter(\n      /**\r\n      * @param {?} __0\r\n      * @return {?}\r\n      */\n      function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            previous = _ref7[0],\n            next = _ref7[1];\n\n        if (!previous) {\n          return true;\n        }\n\n        return previous.x !== next.x || previous.y !== next.y;\n      }), map(\n      /**\r\n      * @param {?} __0\r\n      * @return {?}\r\n      */\n      function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            previous = _ref9[0],\n            next = _ref9[1];\n\n        return next;\n      })).subscribe(\n      /**\r\n      * @param {?} __0\r\n      * @return {?}\r\n      */\n      function (_ref10) {\n        var x = _ref10.x,\n            y = _ref10.y,\n            currentDrag$ = _ref10.currentDrag$,\n            clientX = _ref10.clientX,\n            clientY = _ref10.clientY,\n            transformX = _ref10.transformX,\n            transformY = _ref10.transformY,\n            target = _ref10.target;\n\n        _this.zone.run(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          _this.dragging.next({\n            x: x,\n            y: y\n          });\n        });\n\n        requestAnimationFrame(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          if (_this.ghostElement) {\n            /** @type {?} */\n            var transform = \"translate3d(\".concat(transformX, \"px, \").concat(transformY, \"px, 0px)\");\n\n            _this.setElementStyles(_this.ghostElement, {\n              transform: transform,\n              '-webkit-transform': transform,\n              '-ms-transform': transform,\n              '-moz-transform': transform,\n              '-o-transform': transform\n            });\n          }\n        });\n        currentDrag$.next({\n          clientX: clientX,\n          clientY: clientY,\n          dropData: _this.dropData,\n          target: target\n        });\n      });\n    }\n    /**\r\n     * @param {?} changes\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      if (changes.dragAxis) {\n        this.checkEventListeners();\n      }\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.unsubscribeEventListeners();\n      this.pointerDown$.complete();\n      this.pointerMove$.complete();\n      this.pointerUp$.complete();\n      this.destroy$.next();\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"checkEventListeners\",\n    value: function checkEventListeners() {\n      var _this2 = this;\n\n      /** @type {?} */\n      var canDrag = this.canDrag();\n      /** @type {?} */\n\n      var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n      if (canDrag && !hasEventListeners) {\n        this.zone.runOutsideAngular(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          _this2.eventListenerSubscriptions.mousedown = _this2.renderer.listen(_this2.element.nativeElement, 'mousedown',\n          /**\r\n          * @param {?} event\r\n          * @return {?}\r\n          */\n          function (event) {\n            _this2.onMouseDown(event);\n          });\n          _this2.eventListenerSubscriptions.mouseup = _this2.renderer.listen('document', 'mouseup',\n          /**\r\n          * @param {?} event\r\n          * @return {?}\r\n          */\n          function (event) {\n            _this2.onMouseUp(event);\n          });\n          _this2.eventListenerSubscriptions.touchstart = _this2.renderer.listen(_this2.element.nativeElement, 'touchstart',\n          /**\r\n          * @param {?} event\r\n          * @return {?}\r\n          */\n          function (event) {\n            _this2.onTouchStart(event);\n          });\n          _this2.eventListenerSubscriptions.touchend = _this2.renderer.listen('document', 'touchend',\n          /**\r\n          * @param {?} event\r\n          * @return {?}\r\n          */\n          function (event) {\n            _this2.onTouchEnd(event);\n          });\n          _this2.eventListenerSubscriptions.touchcancel = _this2.renderer.listen('document', 'touchcancel',\n          /**\r\n          * @param {?} event\r\n          * @return {?}\r\n          */\n          function (event) {\n            _this2.onTouchEnd(event);\n          });\n          _this2.eventListenerSubscriptions.mouseenter = _this2.renderer.listen(_this2.element.nativeElement, 'mouseenter',\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this2.onMouseEnter();\n          });\n          _this2.eventListenerSubscriptions.mouseleave = _this2.renderer.listen(_this2.element.nativeElement, 'mouseleave',\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this2.onMouseLeave();\n          });\n        });\n      } else if (!canDrag && hasEventListeners) {\n        this.unsubscribeEventListeners();\n      }\n    }\n    /**\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      var _this3 = this;\n\n      if (event.button === 0) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n          /**\r\n          * @param {?} mouseMoveEvent\r\n          * @return {?}\r\n          */\n          function (mouseMoveEvent) {\n            _this3.pointerMove$.next({\n              event: mouseMoveEvent,\n              clientX: mouseMoveEvent.clientX,\n              clientY: mouseMoveEvent.clientY\n            });\n          });\n        }\n\n        this.pointerDown$.next({\n          event: event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n    }\n    /**\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (event.button === 0) {\n        if (this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove();\n          delete this.eventListenerSubscriptions.mousemove;\n        }\n\n        this.pointerUp$.next({\n          event: event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n    }\n    /**\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      var _this4 = this;\n\n      /** @type {?} */\n      var startScrollPosition;\n      /** @type {?} */\n\n      var isDragActivated;\n      /** @type {?} */\n\n      var hasContainerScrollbar;\n\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n        this.timeLongPress.timerBegin = Date.now();\n        isDragActivated = false;\n        hasContainerScrollbar = this.hasScrollbar();\n        startScrollPosition = this.getScrollPosition();\n      }\n\n      if (!this.eventListenerSubscriptions.touchmove) {\n        /** @type {?} */\n        var contextMenuListener = fromEvent(this.document, 'contextmenu').subscribe(\n        /**\r\n        * @param {?} e\r\n        * @return {?}\r\n        */\n        function (e) {\n          e.preventDefault();\n        });\n        /** @type {?} */\n\n        var touchMoveListener = fromEvent(this.document, 'touchmove', {\n          passive: false\n        }).subscribe(\n        /**\r\n        * @param {?} touchMoveEvent\r\n        * @return {?}\r\n        */\n        function (touchMoveEvent) {\n          if ((_this4.scrollContainer && _this4.scrollContainer.activeLongPressDrag || _this4.touchStartLongPress) && !isDragActivated && hasContainerScrollbar) {\n            isDragActivated = _this4.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n          }\n\n          if ((!_this4.scrollContainer || !_this4.scrollContainer.activeLongPressDrag) && !_this4.touchStartLongPress || !hasContainerScrollbar || isDragActivated) {\n            touchMoveEvent.preventDefault();\n\n            _this4.pointerMove$.next({\n              event: touchMoveEvent,\n              clientX: touchMoveEvent.targetTouches[0].clientX,\n              clientY: touchMoveEvent.targetTouches[0].clientY\n            });\n          }\n        });\n\n        this.eventListenerSubscriptions.touchmove =\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          contextMenuListener.unsubscribe();\n          touchMoveListener.unsubscribe();\n        };\n      }\n\n      this.pointerDown$.next({\n        event: event,\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY\n      });\n    }\n    /**\r\n     * @private\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(event) {\n      if (this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove();\n        delete this.eventListenerSubscriptions.touchmove;\n\n        if (this.scrollContainer && this.scrollContainer.activeLongPressDrag || this.touchStartLongPress) {\n          this.enableScroll();\n        }\n      }\n\n      this.pointerUp$.next({\n        event: event,\n        clientX: event.changedTouches[0].clientX,\n        clientY: event.changedTouches[0].clientY\n      });\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter() {\n      this.setCursor(this.dragCursor);\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave() {\n      this.setCursor('');\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"canDrag\",\n    value: function canDrag() {\n      return this.dragAxis.x || this.dragAxis.y;\n    }\n    /**\r\n     * @private\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(value) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n      }\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"unsubscribeEventListeners\",\n    value: function unsubscribeEventListeners() {\n      var _this5 = this;\n\n      Object.keys(this.eventListenerSubscriptions).forEach(\n      /**\r\n      * @param {?} type\r\n      * @return {?}\r\n      */\n      function (type) {\n        /** @type {?} */\n        _this5.eventListenerSubscriptions[type]();\n\n        delete\n        /** @type {?} */\n        _this5.eventListenerSubscriptions[type];\n      });\n    }\n    /**\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?} styles\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"setElementStyles\",\n    value: function setElementStyles(element, styles) {\n      var _this6 = this;\n\n      Object.keys(styles).forEach(\n      /**\r\n      * @param {?} key\r\n      * @return {?}\r\n      */\n      function (key) {\n        _this6.renderer.setStyle(element, key, styles[key]);\n      });\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"getScrollElement\",\n    value: function getScrollElement() {\n      if (this.scrollContainer) {\n        return this.scrollContainer.elementRef.nativeElement;\n      } else {\n        return this.document.body;\n      }\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"getScrollPosition\",\n    value: function getScrollPosition() {\n      if (this.scrollContainer) {\n        return {\n          top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n          left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n        };\n      } else {\n        return {\n          top: window.pageYOffset || this.document.documentElement.scrollTop,\n          left: window.pageXOffset || this.document.documentElement.scrollLeft\n        };\n      }\n    }\n    /**\r\n     * @private\r\n     * @param {?} event\r\n     * @param {?} touchMoveEvent\r\n     * @param {?} startScrollPosition\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"shouldBeginDrag\",\n    value: function shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n      /** @type {?} */\n      var moveScrollPosition = this.getScrollPosition();\n      /** @type {?} */\n\n      var deltaScroll = {\n        top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n        left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n      };\n      /** @type {?} */\n\n      var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n      /** @type {?} */\n\n      var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n      /** @type {?} */\n\n      var deltaTotal = deltaX + deltaY;\n      /** @type {?} */\n\n      var longPressConfig = this.touchStartLongPress ? this.touchStartLongPress :\n      /* istanbul ignore next */\n      {\n        delta: this.scrollContainer.longPressConfig.delta,\n        delay: this.scrollContainer.longPressConfig.duration\n      };\n\n      if (deltaTotal > longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n        this.timeLongPress.timerBegin = Date.now();\n      }\n\n      this.timeLongPress.timerEnd = Date.now();\n      /** @type {?} */\n\n      var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n      if (duration >= longPressConfig.delay) {\n        this.disableScroll();\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"enableScroll\",\n    value: function enableScroll() {\n      if (this.scrollContainer) {\n        this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');\n      }\n\n      this.renderer.setStyle(this.document.body, 'overflow', '');\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"disableScroll\",\n    value: function disableScroll() {\n      /* istanbul ignore next */\n      if (this.scrollContainer) {\n        this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');\n      }\n\n      this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n    }\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"hasScrollbar\",\n    value: function hasScrollbar() {\n      /** @type {?} */\n      var scrollContainer = this.getScrollElement();\n      /** @type {?} */\n\n      var containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;\n      /** @type {?} */\n\n      var containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;\n      return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n  }]);\n\n  return DraggableDirective;\n}();\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    dragCursor: \"dragCursor\",\n    autoScroll: \"autoScroll\",\n    dropData: \"dropData\",\n    validateDrag: \"validateDrag\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\",\n    touchStartLongPress: \"touchStartLongPress\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nDraggableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: DraggableScrollContainerDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\nDraggableDirective.propDecorators = {\n  dropData: [{\n    type: Input\n  }],\n  dragAxis: [{\n    type: Input\n  }],\n  dragSnapGrid: [{\n    type: Input\n  }],\n  ghostDragEnabled: [{\n    type: Input\n  }],\n  showOriginalElementWhileDragging: [{\n    type: Input\n  }],\n  validateDrag: [{\n    type: Input\n  }],\n  dragCursor: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  ghostElementAppendTo: [{\n    type: Input\n  }],\n  ghostElementTemplate: [{\n    type: Input\n  }],\n  touchStartLongPress: [{\n    type: Input\n  }],\n  autoScroll: [{\n    type: Input\n  }],\n  dragPointerDown: [{\n    type: Output\n  }],\n  dragStart: [{\n    type: Output\n  }],\n  ghostElementCreated: [{\n    type: Output\n  }],\n  dragging: [{\n    type: Output\n  }],\n  dragEnd: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    autoScroll: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }],\n    dropData: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }],\n    touchStartLongPress: [{\n      type: Input\n    }]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} clientX\r\n * @param {?} clientY\r\n * @param {?} rect\r\n * @return {?}\r\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nvar DroppableDirective = /*#__PURE__*/function () {\n  /**\r\n   * @param {?} element\r\n   * @param {?} draggableHelper\r\n   * @param {?} zone\r\n   * @param {?} renderer\r\n   * @param {?} scrollContainer\r\n   */\n  function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n    _classCallCheck(this, DroppableDirective);\n\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\r\n     * Called when a draggable element starts overlapping the element\r\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\r\n     * Called when a draggable element stops overlapping the element\r\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\r\n     * Called when a draggable element is moved over the element\r\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\r\n     * Called when a draggable element is dropped on this element\r\n     */\n\n    this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n  }\n  /**\r\n   * @return {?}\r\n   */\n\n\n  _createClass(DroppableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this7 = this;\n\n      this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      /**\r\n      * @param {?} drag$\r\n      * @return {?}\r\n      */\n      function (drag$) {\n        addClass(_this7.renderer, _this7.element, _this7.dragActiveClass);\n        /** @type {?} */\n\n        var droppableElement = {\n          updateCache: true\n        };\n        /** @type {?} */\n\n        var deregisterScrollListener = _this7.renderer.listen(_this7.scrollContainer ? _this7.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          droppableElement.updateCache = true;\n        });\n        /** @type {?} */\n\n\n        var currentDragDropData;\n        /** @type {?} */\n\n        var overlaps$ = drag$.pipe(map(\n        /**\r\n        * @param {?} __0\r\n        * @return {?}\r\n        */\n        function (_ref11) {\n          var clientX = _ref11.clientX,\n              clientY = _ref11.clientY,\n              dropData = _ref11.dropData,\n              target = _ref11.target;\n          currentDragDropData = dropData;\n\n          if (droppableElement.updateCache) {\n            droppableElement.rect = _this7.element.nativeElement.getBoundingClientRect();\n\n            if (_this7.scrollContainer) {\n              droppableElement.scrollContainerRect = _this7.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n            }\n\n            droppableElement.updateCache = false;\n          }\n          /** @type {?} */\n\n\n          var isWithinElement = isCoordinateWithinRectangle(clientX, clientY,\n          /** @type {?} */\n          droppableElement.rect);\n          /** @type {?} */\n\n          var isDropAllowed = !_this7.validateDrop || _this7.validateDrop({\n            clientX: clientX,\n            clientY: clientY,\n            target: target\n          });\n\n          if (droppableElement.scrollContainerRect) {\n            return isWithinElement && isDropAllowed && isCoordinateWithinRectangle(clientX, clientY,\n            /** @type {?} */\n            droppableElement.scrollContainerRect);\n          } else {\n            return isWithinElement && isDropAllowed;\n          }\n        }));\n        /** @type {?} */\n\n        var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n        /** @type {?} */\n\n        var dragOverActive;\n        overlapsChanged$.pipe(filter(\n        /**\r\n        * @param {?} overlapsNow\r\n        * @return {?}\r\n        */\n        function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          dragOverActive = true;\n          addClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n          _this7.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this7.dragEnter.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlaps$.pipe(filter(\n        /**\r\n        * @param {?} overlapsNow\r\n        * @return {?}\r\n        */\n        function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          _this7.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this7.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlapsChanged$.pipe(pairwise(), filter(\n        /**\r\n        * @param {?} __0\r\n        * @return {?}\r\n        */\n        function (_ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n              didOverlap = _ref13[0],\n              overlapsNow = _ref13[1];\n\n          return didOverlap && !overlapsNow;\n        })).subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          dragOverActive = false;\n          removeClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n          _this7.zone.run(\n          /**\r\n          * @return {?}\r\n          */\n          function () {\n            _this7.dragLeave.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        drag$.subscribe({\n          complete:\n          /**\r\n          * @return {?}\r\n          */\n          function complete() {\n            deregisterScrollListener();\n            removeClass(_this7.renderer, _this7.element, _this7.dragActiveClass);\n\n            if (dragOverActive) {\n              removeClass(_this7.renderer, _this7.element, _this7.dragOverClass);\n\n              _this7.zone.run(\n              /**\r\n              * @return {?}\r\n              */\n              function () {\n                _this7.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      });\n    }\n    /**\r\n     * @return {?}\r\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.currentDragSubscription) {\n        this.currentDragSubscription.unsubscribe();\n      }\n    }\n  }]);\n\n  return DroppableDirective;\n}();\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\",\n    validateDrop: \"validateDrop\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n/** @nocollapse */\n\nDroppableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableScrollContainerDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nDroppableDirective.propDecorators = {\n  dragOverClass: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  validateDrop: [{\n    type: Input\n  }],\n  dragEnter: [{\n    type: Output\n  }],\n  dragLeave: [{\n    type: Output\n  }],\n  dragOver: [{\n    type: Output\n  }],\n  drop: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }],\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    validateDrop: [{\n      type: Input\n    }]\n  });\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar DragAndDropModule = function DragAndDropModule() {\n  _classCallCheck(this, DragAndDropModule);\n};\n\nDragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };","map":{"version":3,"sources":["angular-draggable-droppable/lib/draggable-helper.provider.ts","angular-draggable-droppable/lib/draggable-scroll-container.directive.ts","angular-draggable-droppable/lib/util.ts","angular-draggable-droppable/lib/draggable.directive.ts","angular-draggable-droppable/lib/droppable.directive.ts","angular-draggable-droppable/lib/drag-and-drop.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\nexport interface CurrentDragData {\n  clientX: number;\n  clientY: number;\n  dropData: any;\n  target: EventTarget;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class DraggableHelper {\n  currentDrag = new Subject<Subject<CurrentDragData>>();\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnInit,\n  Renderer2,\n} from '@angular/core';\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\n@Directive({\n  selector: '[mwlDraggableScrollContainer]',\n})\nexport class DraggableScrollContainerDirective {\n  /**\n   * Trigger the DragStart after a long touch in scrollable container when true\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n   */\n  @Input() activeLongPressDrag: boolean = false;\n\n  /**\n   * Configuration of a long touch\n   * Duration in ms of a long touch before activating DragStart\n   * Delta of the\n   * @deprecated will be removed in v5 (use [touchStartLongPress]=\"{delay: 300, delta: 30}\" on the mwlDraggable element instead)\n   */\n  @Input() longPressConfig = { duration: 300, delta: 30 };\n\n  /**\n   * @hidden\n   */\n  constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import { ElementRef, Renderer2 } from '@angular/core';\n\nexport function addClass(\n  renderer: Renderer2,\n  element: ElementRef<HTMLElement>,\n  classToAdd: string\n) {\n  if (classToAdd) {\n    classToAdd\n      .split(' ')\n      .forEach((className) =>\n        renderer.addClass(element.nativeElement, className)\n      );\n  }\n}\n\nexport function removeClass(\n  renderer: Renderer2,\n  element: ElementRef<HTMLElement>,\n  classToRemove: string\n) {\n  if (classToRemove) {\n    classToRemove\n      .split(' ')\n      .forEach((className) =>\n        renderer.removeClass(element.nativeElement, className)\n      );\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges,\n  Inject,\n  TemplateRef,\n  ViewContainerRef,\n  Optional,\n} from '@angular/core';\nimport {\n  Subject,\n  Observable,\n  merge,\n  ReplaySubject,\n  combineLatest,\n  fromEvent,\n} from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  take,\n  takeLast,\n  pairwise,\n  share,\n  filter,\n  count,\n  startWith,\n} from 'rxjs/operators';\nimport { CurrentDragData, DraggableHelper } from './draggable-helper.provider';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from '@mattlewis92/dom-autoscroller';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\nimport { addClass, removeClass } from './util';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport interface DragPointerDownEvent extends Coordinates {}\n\nexport interface DragStartEvent {\n  cancelDrag$: ReplaySubject<void>;\n}\n\nexport interface DragMoveEvent extends Coordinates {}\n\nexport interface DragEndEvent extends Coordinates {\n  dragCancelled: boolean;\n}\n\nexport interface ValidateDragParams extends Coordinates {\n  transform: {\n    x: number;\n    y: number;\n  };\n}\n\nexport type ValidateDrag = (params: ValidateDragParams) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\nexport interface TimeLongPress {\n  timerBegin: number;\n  timerEnd: number;\n}\n\nexport interface GhostElementCreatedEvent {\n  clientX: number;\n  clientY: number;\n  element: HTMLElement;\n}\n\n@Directive({\n  selector: '[mwlDraggable]',\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input() dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input() dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input() dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input() ghostDragEnabled: boolean = true;\n\n  /**\n   * Show the original element when ghostDragEnabled is true\n   */\n  @Input() showOriginalElementWhileDragging: boolean = false;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input() validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when hovering over a draggable element\n   */\n  @Input() dragCursor: string = '';\n\n  /**\n   * The css class to apply when the element is being dragged\n   */\n  @Input() dragActiveClass: string;\n\n  /**\n   * The element the ghost element will be appended to. Default is next to the dragged element\n   */\n  @Input() ghostElementAppendTo: HTMLElement;\n\n  /**\n   * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.\n   */\n  @Input() ghostElementTemplate: TemplateRef<any>;\n\n  /**\n   * Amount of milliseconds to wait on touch devices before starting to drag the element (so that you can scroll the page by touching a draggable element)\n   */\n  @Input() touchStartLongPress: { delay: number; delta: number };\n\n  /*\n   * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller\n   */\n  @Input() autoScroll: {\n    margin:\n      | number\n      | { top?: number; left?: number; right?: number; bottom?: number };\n    maxSpeed?:\n      | number\n      | { top?: number; left?: number; right?: number; bottom?: number };\n    scrollWhenOutside?: boolean;\n  } = {\n    margin: 20,\n  };\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output() dragPointerDown = new EventEmitter<DragPointerDownEvent>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event.\n   * If you call $event.cancelDrag$.emit() it will cancel the current drag\n   */\n  @Output() dragStart = new EventEmitter<DragStartEvent>();\n\n  /**\n   * Called after the ghost element has been created\n   */\n  @Output() ghostElementCreated = new EventEmitter<GhostElementCreatedEvent>();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output() dragging = new EventEmitter<DragMoveEvent>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output() dragEnd = new EventEmitter<DragEndEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerDown$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerMove$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerUp$ = new Subject<PointerEvent>();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  private ghostElement: HTMLElement | null;\n\n  private destroy$ = new Subject();\n\n  private timeLongPress: TimeLongPress = { timerBegin: 0, timerEnd: 0 };\n\n  private scroller: { destroy: () => void };\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private vcr: ViewContainerRef,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective,\n    @Inject(DOCUMENT) private document: any\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDragged$: Observable<any> = this.pointerDown$.pipe(\n      filter(() => this.canDrag()),\n      mergeMap((pointerDownEvent: PointerEvent) => {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        }\n\n        // hack to prevent text getting selected in safari while dragging\n        const globalDragStyle: HTMLStyleElement = this.renderer.createElement(\n          'style'\n        );\n        this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n        this.renderer.appendChild(\n          globalDragStyle,\n          this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `)\n        );\n        requestAnimationFrame(() => {\n          this.document.head.appendChild(globalDragStyle);\n        });\n\n        const startScrollPosition = this.getScrollPosition();\n\n        const scrollContainerScroll$ = new Observable((observer) => {\n          const scrollContainer = this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window';\n          return this.renderer.listen(scrollContainer, 'scroll', (e) =>\n            observer.next(e)\n          );\n        }).pipe(\n          startWith(startScrollPosition),\n          map(() => this.getScrollPosition())\n        );\n\n        const currentDrag$ = new Subject<CurrentDragData>();\n        const cancelDrag$ = new ReplaySubject<void>();\n\n        this.zone.run(() => {\n          this.dragPointerDown.next({ x: 0, y: 0 });\n        });\n\n        const dragComplete$ = merge(\n          this.pointerUp$,\n          this.pointerDown$,\n          cancelDrag$,\n          this.destroy$\n        ).pipe(share());\n\n        const pointerMove = combineLatest([\n          this.pointerMove$,\n          scrollContainerScroll$,\n        ]).pipe(\n          map(([pointerMoveEvent, scroll]) => {\n            return {\n              currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top,\n              target: pointerMoveEvent.event.target,\n            };\n          }),\n          map((moveData) => {\n            if (this.dragSnapGrid.x) {\n              moveData.transformX =\n                Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                this.dragSnapGrid.x;\n            }\n\n            if (this.dragSnapGrid.y) {\n              moveData.transformY =\n                Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                this.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }),\n          map((moveData) => {\n            if (!this.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!this.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }),\n          map((moveData) => {\n            const scrollX = moveData.scrollLeft - startScrollPosition.left;\n            const scrollY = moveData.scrollTop - startScrollPosition.top;\n            return {\n              ...moveData,\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY,\n            };\n          }),\n          filter(\n            ({ x, y, transformX, transformY }) =>\n              !this.validateDrag ||\n              this.validateDrag({\n                x,\n                y,\n                transform: { x: transformX, y: transformY },\n              })\n          ),\n          takeUntil(dragComplete$),\n          share()\n        );\n\n        const dragStarted$ = pointerMove.pipe(take(1), share());\n        const dragEnded$ = pointerMove.pipe(takeLast(1), share());\n\n        dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n          this.zone.run(() => {\n            this.dragStart.next({ cancelDrag$ });\n          });\n\n          this.scroller = autoScroll(\n            [\n              this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : this.document.defaultView,\n            ],\n            {\n              ...this.autoScroll,\n              autoScroll() {\n                return true;\n              },\n            }\n          );\n          addClass(this.renderer, this.element, this.dragActiveClass);\n\n          if (this.ghostDragEnabled) {\n            const rect = this.element.nativeElement.getBoundingClientRect();\n            const clone = this.element.nativeElement.cloneNode(\n              true\n            ) as HTMLElement;\n            if (!this.showOriginalElementWhileDragging) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                'hidden'\n              );\n            }\n\n            if (this.ghostElementAppendTo) {\n              this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              this.element.nativeElement.parentNode!.insertBefore(\n                clone,\n                this.element.nativeElement.nextSibling\n              );\n            }\n\n            this.ghostElement = clone;\n\n            this.document.body.style.cursor = this.dragCursor;\n\n            this.setElementStyles(clone, {\n              position: 'fixed',\n              top: `${rect.top}px`,\n              left: `${rect.left}px`,\n              width: `${rect.width}px`,\n              height: `${rect.height}px`,\n              cursor: this.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none',\n            });\n\n            if (this.ghostElementTemplate) {\n              const viewRef = this.vcr.createEmbeddedView(\n                this.ghostElementTemplate\n              );\n              clone.innerHTML = '';\n              viewRef.rootNodes\n                .filter((node) => node instanceof Node)\n                .forEach((node) => {\n                  clone.appendChild(node);\n                });\n              dragEnded$.subscribe(() => {\n                this.vcr.remove(this.vcr.indexOf(viewRef));\n              });\n            }\n\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone,\n              });\n            });\n\n            dragEnded$.subscribe(() => {\n              clone.parentElement!.removeChild(clone);\n              this.ghostElement = null;\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                ''\n              );\n            });\n          }\n\n          this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n\n        dragEnded$\n          .pipe(\n            mergeMap((dragEndData) => {\n              const dragEndData$ = cancelDrag$.pipe(\n                count(),\n                take(1),\n                map((calledCount) => ({\n                  ...dragEndData,\n                  dragCancelled: calledCount > 0,\n                }))\n              );\n              cancelDrag$.complete();\n              return dragEndData$;\n            })\n          )\n          .subscribe(({ x, y, dragCancelled }) => {\n            this.scroller.destroy();\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y, dragCancelled });\n            });\n            removeClass(this.renderer, this.element, this.dragActiveClass);\n            currentDrag$.complete();\n          });\n\n        merge(dragComplete$, dragEnded$)\n          .pipe(take(1))\n          .subscribe(() => {\n            requestAnimationFrame(() => {\n              this.document.head.removeChild(globalDragStyle);\n            });\n          });\n\n        return pointerMove;\n      }),\n      share()\n    );\n\n    merge(\n      pointerDragged$.pipe(\n        take(1),\n        map((value) => [, value])\n      ),\n      pointerDragged$.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        }),\n        map(([previous, next]) => next)\n      )\n      .subscribe(\n        ({\n          x,\n          y,\n          currentDrag$,\n          clientX,\n          clientY,\n          transformX,\n          transformY,\n          target,\n        }) => {\n          this.zone.run(() => {\n            this.dragging.next({ x, y });\n          });\n          requestAnimationFrame(() => {\n            if (this.ghostElement) {\n              const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n              this.setElementStyles(this.ghostElement, {\n                transform,\n                '-webkit-transform': transform,\n                '-ms-transform': transform,\n                '-moz-transform': transform,\n                '-o-transform': transform,\n              });\n            }\n          });\n          currentDrag$.next({\n            clientX,\n            clientY,\n            dropData: this.dropData,\n            target,\n          });\n        }\n      );\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (event.button === 0) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n          'document',\n          'mousemove',\n          (mouseMoveEvent: MouseEvent) => {\n            this.pointerMove$.next({\n              event: mouseMoveEvent,\n              clientX: mouseMoveEvent.clientX,\n              clientY: mouseMoveEvent.clientY,\n            });\n          }\n        );\n      }\n      this.pointerDown$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY,\n      });\n    }\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (event.button === 0) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n      this.pointerUp$.next({\n        event,\n        clientX: event.clientX,\n        clientY: event.clientY,\n      });\n    }\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    let startScrollPosition: any;\n    let isDragActivated: boolean;\n    let hasContainerScrollbar: boolean;\n    if (\n      (this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n      this.touchStartLongPress\n    ) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n\n    if (!this.eventListenerSubscriptions.touchmove) {\n      const contextMenuListener = fromEvent<Event>(\n        this.document,\n        'contextmenu'\n      ).subscribe((e) => {\n        e.preventDefault();\n      });\n\n      const touchMoveListener = fromEvent<TouchEvent>(\n        this.document,\n        'touchmove',\n        {\n          passive: false,\n        }\n      ).subscribe((touchMoveEvent) => {\n        if (\n          ((this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n            this.touchStartLongPress) &&\n          !isDragActivated &&\n          hasContainerScrollbar\n        ) {\n          isDragActivated = this.shouldBeginDrag(\n            event,\n            touchMoveEvent,\n            startScrollPosition\n          );\n        }\n        if (\n          ((!this.scrollContainer ||\n            !this.scrollContainer.activeLongPressDrag) &&\n            !this.touchStartLongPress) ||\n          !hasContainerScrollbar ||\n          isDragActivated\n        ) {\n          touchMoveEvent.preventDefault();\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY,\n          });\n        }\n      });\n\n      this.eventListenerSubscriptions.touchmove = () => {\n        contextMenuListener.unsubscribe();\n        touchMoveListener.unsubscribe();\n      };\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY,\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n\n      if (\n        (this.scrollContainer && this.scrollContainer.activeLongPressDrag) ||\n        this.touchStartLongPress\n      ) {\n        this.enableScroll();\n      }\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY,\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor('');\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach((type) => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n\n  private setElementStyles(\n    element: HTMLElement,\n    styles: { [key: string]: string }\n  ) {\n    Object.keys(styles).forEach((key) => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  private getScrollElement() {\n    if (this.scrollContainer) {\n      return this.scrollContainer.elementRef.nativeElement;\n    } else {\n      return this.document.body;\n    }\n  }\n\n  private getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft,\n      };\n    } else {\n      return {\n        top: window.pageYOffset || this.document.documentElement.scrollTop,\n        left: window.pageXOffset || this.document.documentElement.scrollLeft,\n      };\n    }\n  }\n\n  private shouldBeginDrag(\n    event: TouchEvent,\n    touchMoveEvent: TouchEvent,\n    startScrollPosition: { top: number; left: number }\n  ): boolean {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left),\n    };\n    const deltaX =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX\n      ) - deltaScroll.left;\n    const deltaY =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY\n      ) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    const longPressConfig = this.touchStartLongPress\n      ? this.touchStartLongPress\n      : /* istanbul ignore next */\n        {\n          delta: this.scrollContainer.longPressConfig.delta,\n          delay: this.scrollContainer.longPressConfig.duration,\n        };\n    if (\n      deltaTotal > longPressConfig.delta ||\n      deltaScroll.top > 0 ||\n      deltaScroll.left > 0\n    ) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n    this.timeLongPress.timerEnd = Date.now();\n    const duration =\n      this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n    if (duration >= longPressConfig.delay) {\n      this.disableScroll();\n      return true;\n    }\n    return false;\n  }\n\n  private enableScroll() {\n    if (this.scrollContainer) {\n      this.renderer.setStyle(\n        this.scrollContainer.elementRef.nativeElement,\n        'overflow',\n        ''\n      );\n    }\n    this.renderer.setStyle(this.document.body, 'overflow', '');\n  }\n\n  private disableScroll() {\n    /* istanbul ignore next */\n    if (this.scrollContainer) {\n      this.renderer.setStyle(\n        this.scrollContainer.elementRef.nativeElement,\n        'overflow',\n        'hidden'\n      );\n    }\n    this.renderer.setStyle(this.document.body, 'overflow', 'hidden');\n  }\n\n  private hasScrollbar(): boolean {\n    const scrollContainer = this.getScrollElement();\n    const containerHasHorizontalScroll =\n      scrollContainer.scrollWidth > scrollContainer.clientWidth;\n    const containerHasVerticalScroll =\n      scrollContainer.scrollHeight > scrollContainer.clientHeight;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone,\n  Input,\n  Renderer2,\n  Optional,\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\nimport { addClass, removeClass } from './util';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropEvent<T = any> {\n  dropData: T;\n}\n\nexport interface ValidateDropParams {\n  /**\n   * ClientX value of the mouse location where the drop occurred\n   */\n  clientX: number;\n  /**\n   * ClientY value of the mouse location where the drop occurred\n   */\n  clientY: number;\n  /**\n   * The target of the event where the drop occurred\n   */\n  target: EventTarget;\n}\n\nexport type ValidateDrop = (params: ValidateDropParams) => boolean;\n\n@Directive({\n  selector: '[mwlDroppable]',\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Added to the element when an element is dragged over it\n   */\n  @Input() dragOverClass: string;\n\n  /**\n   * Added to the element any time a draggable element is being dragged\n   */\n  @Input() dragActiveClass: string;\n\n  /**\n   * Allow custom behaviour to control when the element is dropped\n   */\n  @Input() validateDrop: ValidateDrop;\n\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output() dragEnter = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output() dragLeave = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output() dragOver = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output() drop = new EventEmitter<DropEvent>(); // tslint:disable-line no-output-named-after-standard-event\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private renderer: Renderer2,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective\n  ) {}\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      (drag$) => {\n        addClass(this.renderer, this.element, this.dragActiveClass);\n        const droppableElement: {\n          rect?: ClientRect;\n          updateCache: boolean;\n          scrollContainerRect?: ClientRect;\n        } = {\n          updateCache: true,\n        };\n\n        const deregisterScrollListener = this.renderer.listen(\n          this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window',\n          'scroll',\n          () => {\n            droppableElement.updateCache = true;\n          }\n        );\n\n        let currentDragDropData: any;\n        const overlaps$ = drag$.pipe(\n          map(({ clientX, clientY, dropData, target }) => {\n            currentDragDropData = dropData;\n            if (droppableElement.updateCache) {\n              droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n              if (this.scrollContainer) {\n                droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n              droppableElement.updateCache = false;\n            }\n            const isWithinElement = isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableElement.rect as ClientRect\n            );\n\n            const isDropAllowed =\n              !this.validateDrop ||\n              this.validateDrop({ clientX, clientY, target });\n\n            if (droppableElement.scrollContainerRect) {\n              return (\n                isWithinElement &&\n                isDropAllowed &&\n                isCoordinateWithinRectangle(\n                  clientX,\n                  clientY,\n                  droppableElement.scrollContainerRect as ClientRect\n                )\n              );\n            } else {\n              return isWithinElement && isDropAllowed;\n            }\n          })\n        );\n\n        const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged$\n          .pipe(filter((overlapsNow) => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            addClass(this.renderer, this.element, this.dragOverClass);\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData,\n              });\n            });\n          });\n\n        overlaps$.pipe(filter((overlapsNow) => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData,\n            });\n          });\n        });\n\n        overlapsChanged$\n          .pipe(\n            pairwise(),\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            removeClass(this.renderer, this.element, this.dragOverClass);\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData,\n              });\n            });\n          });\n\n        drag$.subscribe({\n          complete: () => {\n            deregisterScrollListener();\n            removeClass(this.renderer, this.element, this.dragActiveClass);\n            if (dragOverActive) {\n              removeClass(this.renderer, this.element, this.dragOverClass);\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData,\n                });\n              });\n            }\n          },\n        });\n      }\n    );\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\n@NgModule({\n  declarations: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective,\n  ],\n  exports: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective,\n  ],\n})\nexport class DragAndDropModule {}\n"]},"metadata":{},"sourceType":"module"}